"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_App_tsx",{

/***/ "./src/game/components/Match.ts":
/*!**************************************!*\
  !*** ./src/game/components/Match.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Match; }\n/* harmony export */ });\nclass Gem {\n}\nclass Match {\n    drawField() {\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.gemGroup = this.scene.add.group();\n        for(let i = 0; i < this.fieldSize; i++){\n            this.gameArray[i] = [];\n            this.inputArray[i] = [];\n            for(let j = 0; j < this.fieldSize; j++){\n                let color = this.randomColor();\n                let x = this.startX + (this.gemSize * j + this.gemSize / 2);\n                let y = this.startY + (this.gemSize * i + this.gemSize / 2);\n                let gem = this.scene.add.sprite(x, y, color);\n                this.gemGroup.add(gem);\n                let gemData = {\n                    gemColor: color,\n                    gemSprite: gem,\n                    isEmpty: false\n                };\n                this.gameArray[i][j] = gemData;\n            // let hitBox = this.scene.add.rectangle( x, y, this.gemSize, this.gemSize, 0x000000, 0.2)\n            // hitBox.on(\"pointerdown\", ( pointer: Phaser.Input.Pointer)=>{\n            //     this.gemSelect(pointer,i,j)\n            // }, this);\n            // hitBox.setInteractive()\n            // this.inputArray[i][j] = hitBox\n            }\n        }\n    }\n    isMatch(row, col) {\n        return this.isHorizontalMatch(row, col) || this.isVerticalMatch(row, col);\n    }\n    isHorizontalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row, col - 1).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row, col - 2).gemColor;\n    }\n    isVerticalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row - 1, col).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row - 2, col).gemColor;\n    }\n    gemAt(row, col) {\n        if (row < 0 || row >= this.fieldSize || col < 0 || col >= this.fieldSize) {\n            return -1;\n        }\n        return this.gameArray[row][col];\n    }\n    gemSelect(pointer, row, col) {\n        if (this.canPick) {\n            this.dragging = true;\n            // let row = Math.floor(pointer.y / this.gemSize);\n            // let col = Math.floor(pointer.x / this.gemSize);\n            let pickedGem = this.gemAt(row, col);\n            if (pickedGem != -1) {\n                if (this.selectedGem == null) {\n                    pickedGem.gemSprite.setScale(1.2);\n                    pickedGem.gemSprite.setDepth(1);\n                    this.selectedGem = pickedGem;\n                } else {\n                    if (this.areTheSame(pickedGem, this.selectedGem)) {\n                        this.selectedGem.gemSprite.setScale(1);\n                        this.selectedGem = null;\n                    } else {\n                        if (this.areNext(pickedGem, this.selectedGem)) {\n                            this.selectedGem.gemSprite.setScale(1);\n                            this.swapGems(this.selectedGem, pickedGem, true);\n                        } else {\n                            this.selectedGem.gemSprite.setScale(1);\n                            pickedGem.gemSprite.setScale(1.2);\n                            this.selectedGem = pickedGem;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    gemSelect2(pointer, row, col) {\n        if (this.canPick) {\n            this.dragging = true;\n            // let row = Math.floor(pointer.y / this.gemSize);\n            // let col = Math.floor(pointer.x / this.gemSize);\n            let pickedGem = this.gemAt(row, col);\n            if (pickedGem != -1) {\n                if (this.selectedGem == null) {\n                    pickedGem.gemSprite.setScale(1.2);\n                    pickedGem.gemSprite.setDepth(1);\n                    this.selectedGem = pickedGem;\n                } else {\n                    if (this.areTheSame(pickedGem, this.selectedGem)) {\n                        this.selectedGem.gemSprite.setScale(1);\n                        this.selectedGem = null;\n                    } else {\n                        if (this.areNext(pickedGem, this.selectedGem)) {\n                            this.selectedGem.gemSprite.setScale(1);\n                            this.swapGems(this.selectedGem, pickedGem, true);\n                        } else {\n                            this.selectedGem.gemSprite.setScale(1);\n                            pickedGem.gemSprite.setScale(1.2);\n                            this.selectedGem = pickedGem;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    startSwipe(pointer) {\n        if (this.dragging && this.selectedGem != null) {\n            let deltaX = pointer.downX - pointer.x;\n            let deltaY = pointer.downY - pointer.y;\n            let deltaRow = 0;\n            let deltaCol = 0;\n            if (deltaX > this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = -1;\n            }\n            if (deltaX < -this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = 1;\n            }\n            if (deltaY > this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = -1;\n            }\n            if (deltaY < -this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = 1;\n            }\n            if (deltaRow + deltaCol != 0) {\n                let pickedGem = this.gemAt(this.getGemRow(this.selectedGem) + deltaRow, this.getGemCol(this.selectedGem) + deltaCol);\n                if (pickedGem != -1) {\n                    this.selectedGem.gemSprite.setScale(1);\n                    this.swapGems(this.selectedGem, pickedGem, true);\n                    this.dragging = false;\n                }\n            }\n        }\n    }\n    stopSwipe() {\n        this.dragging = false;\n    }\n    areTheSame(gem1, gem2) {\n        return this.getGemRow(gem1) == this.getGemRow(gem2) && this.getGemCol(gem1) == this.getGemCol(gem2);\n    }\n    getGemRow(gem) {\n        return Math.floor(gem.gemSprite.y / this.gemSize);\n    }\n    getGemCol(gem) {\n        return Math.floor(gem.gemSprite.x / this.gemSize);\n    }\n    areNext(gem1, gem2) {\n        return Math.abs(this.getGemRow(gem1) - this.getGemRow(gem2)) + Math.abs(this.getGemCol(gem1) - this.getGemCol(gem2)) == 1;\n    }\n    swapGems(gem1, gem2, swapBack) {\n        this.swappingGems = 2;\n        this.canPick = false;\n        let fromColor = gem1.gemColor;\n        let fromSprite = gem1.gemSprite;\n        let toColor = gem2.gemColor;\n        let toSprite = gem2.gemSprite;\n        let gem1Row = this.getGemRow(gem1);\n        let gem1Col = this.getGemCol(gem1);\n        let gem2Row = this.getGemRow(gem2);\n        let gem2Col = this.getGemCol(gem2);\n        this.gameArray[gem1Row][gem1Col].gemColor = toColor;\n        this.gameArray[gem1Row][gem1Col].gemSprite = toSprite;\n        this.gameArray[gem2Row][gem2Col].gemColor = fromColor;\n        this.gameArray[gem2Row][gem2Col].gemSprite = fromSprite;\n        this.tweenGem(gem1, gem2, swapBack);\n        this.tweenGem(gem2, gem1, swapBack);\n    }\n    tweenGem(gem1, gem2, swapBack) {\n        let row = this.getGemRow(gem1);\n        let col = this.getGemCol(gem1);\n        this.scene.tweens.add({\n            targets: this.gameArray[row][col].gemSprite,\n            x: col * this.gemSize + this.gemSize / 2,\n            y: row * this.gemSize + this.gemSize / 2,\n            duration: this.swapSpeed,\n            callbackScope: this,\n            onComplete: function() {\n                this.swappingGems--;\n                if (this.swappingGems == 0) {\n                    if (!this.matchInBoard() && swapBack) {\n                        this.swapGems(gem1, gem2, false);\n                    } else {\n                        if (this.matchInBoard()) {\n                            this.handleMatches();\n                        } else {\n                            this.canPick = true;\n                            this.selectedGem = null;\n                        }\n                    }\n                }\n            }\n        });\n    }\n    matchInBoard() {\n        for(let i = 0; i < this.fieldSize; i++){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (this.isMatch(i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    handleMatches() {\n        this.removeMap = [];\n        for(let i = 0; i < this.fieldSize; i++){\n            this.removeMap[i] = [];\n            for(let j = 0; j < this.fieldSize; j++){\n                this.removeMap[i].push(0);\n            }\n        }\n        this.markMatches(\"horizontal\");\n        this.markMatches(\"vertical\");\n        this.destroyGems();\n    }\n    markMatches(direction) {\n        for(let i = 0; i < this.fieldSize; i++){\n            let colorStreak = 1;\n            let currentColor = -1;\n            let startStreak = 0;\n            let colorToWatch = 0;\n            for(let j = 0; j < this.fieldSize; j++){\n                if (direction == \"horizontal\") {\n                    colorToWatch = this.gemAt(i, j).gemColor;\n                } else {\n                    colorToWatch = this.gemAt(j, i).gemColor;\n                }\n                if (colorToWatch == currentColor) {\n                    colorStreak++;\n                }\n                if (colorToWatch != currentColor || j == this.fieldSize - 1) {\n                    if (colorStreak >= 3) {\n                        if (direction == \"horizontal\") {\n                            console.log(\"HORIZONTAL :: Length = \" + colorStreak + \" :: Start = (\" + i + \",\" + startStreak + \") :: Color = \" + currentColor);\n                        } else {\n                            console.log(\"VERTICAL :: Length = \" + colorStreak + \" :: Start = (\" + startStreak + \",\" + i + \") :: Color = \" + currentColor);\n                        }\n                        for(let k = 0; k < colorStreak; k++){\n                            if (direction == \"horizontal\") {\n                                this.removeMap[i][startStreak + k]++;\n                            } else {\n                                this.removeMap[startStreak + k][i]++;\n                            }\n                        }\n                    }\n                    startStreak = j;\n                    colorStreak = 1;\n                    currentColor = colorToWatch;\n                }\n            }\n        }\n    }\n    destroyGems() {\n        let destroyed = 0;\n        for(let i = 0; i < this.fieldSize; i++){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (this.removeMap[i][j] > 0) {\n                    destroyed++;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        alpha: 0.5,\n                        duration: this.destroySpeed,\n                        callbackScope: this,\n                        onComplete: function() {\n                            destroyed--;\n                            this.gameArray[i][j].gemSprite.visible = false;\n                            this.poolArray.push(this.gameArray[i][j].gemSprite);\n                            if (destroyed == 0) {\n                                this.makeGemsFall();\n                                this.replenishField();\n                            }\n                        }\n                    });\n                    this.gameArray[i][j].isEmpty = true;\n                }\n            }\n        }\n    }\n    makeGemsFall() {\n        for(let i = this.fieldSize - 2; i >= 0; i--){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (!this.gameArray[i][j].isEmpty) {\n                    let fallTiles = this.holesBelow(i, j);\n                    if (fallTiles > 0) {\n                        this.scene.tweens.add({\n                            targets: this.gameArray[i][j].gemSprite,\n                            y: this.gameArray[i][j].gemSprite.y + fallTiles * this.gemSize,\n                            duration: this.fallSpeed * fallTiles\n                        });\n                        this.gameArray[i + fallTiles][j] = {\n                            gemSprite: this.gameArray[i][j].gemSprite,\n                            gemColor: this.gameArray[i][j].gemColor,\n                            isEmpty: false\n                        };\n                        this.gameArray[i][j].isEmpty = true;\n                    }\n                }\n            }\n        }\n    }\n    holesBelow(row, col) {\n        let result = 0;\n        for(let i = row + 1; i < this.fieldSize; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    replenishField() {\n        let replenished = 0;\n        for(let j = 0; j < this.fieldSize; j++){\n            let emptySpots = this.holesInCol(j);\n            if (emptySpots > 0) {\n                for(let i = 0; i < emptySpots; i++){\n                    replenished++;\n                    let randomColor = this.randomColor();\n                    this.gameArray[i][j].gemColor = randomColor;\n                    this.gameArray[i][j].gemSprite = this.poolArray.pop();\n                    this.gameArray[i][j].gemSprite.setTexture(randomColor);\n                    this.gameArray[i][j].gemSprite.visible = true;\n                    this.gameArray[i][j].gemSprite.x = this.gemSize * j + this.gemSize / 2;\n                    this.gameArray[i][j].gemSprite.y = this.gemSize / 2 - (emptySpots - i) * this.gemSize;\n                    this.gameArray[i][j].gemSprite.alpha = 1;\n                    this.gameArray[i][j].isEmpty = false;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        y: this.gemSize * i + this.gemSize / 2,\n                        duration: this.fallSpeed * emptySpots,\n                        callbackScope: this,\n                        onComplete: function() {\n                            replenished--;\n                            if (replenished == 0) {\n                                if (this.matchInBoard()) {\n                                    this.scene.time.addEvent({\n                                        delay: 250,\n                                        callback: this.handleMatches()\n                                    });\n                                } else {\n                                    this.canPick = true;\n                                    this.selectedGem = null;\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n    holesInCol(col) {\n        var result = 0;\n        for(let i = 0; i < this.fieldSize; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    randomColor() {\n        return this.gemColors[Phaser.Math.Between(0, this.gemColors.length - 1)];\n    }\n    constructor(scene, x, y){\n        this.startX = 0;\n        this.startY = 0;\n        //\n        this.fieldSize = 7;\n        this.gemSize = 128;\n        this.swapSpeed = 200;\n        this.fallSpeed = 100;\n        this.destroySpeed = 200;\n        this.gemColors = [\n            \"blue\",\n            \"green\",\n            \"orange\",\n            \"red\"\n        ];\n        //\n        this.canPick = true;\n        this.dragging = false;\n        //\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.scene = scene;\n        // this.startX = x - (this.fieldSize*this.gemSize /2) \n        // this.startY = y - (this.fieldSize*this.gemSize /2) \n        this.drawField();\n        // this.scene.input.on(\"pointerdown\", this.gemSelect, this);\n        this.scene.input.on(\"pointermove\", this.startSwipe, this);\n        this.scene.input.on(\"pointerup\", this.stopSwipe, this);\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNqQixFQUFFO2FBQ0ZSLFlBQW9CO2FBQ3BCTSxVQUFrQjthQUNsQndELFlBQW9CO2FBQ3BCeUIsWUFBb0I7YUFDcEJOLGVBQXVCO2FBQ3ZCaUIsWUFBc0I7WUFBQztZQUFPO1lBQVE7WUFBUztTQUFNO1FBQ3JELEVBQUU7YUFDRjNFLFVBQW1CO2FBQ25CQyxXQUFvQjtRQUNwQixFQUFFO2FBQ0ZoQyxZQUFpQixFQUFFO2FBQ25CQyxZQUFpQixFQUFFO2FBQ25CQyxhQUFrQixFQUFFO1FBUWhCLElBQUksQ0FBQ0UsS0FBSyxHQUFHQTtRQUNiLHNEQUFzRDtRQUN0RCxzREFBc0Q7UUFFdEQsSUFBSSxDQUFDTCxTQUFTO1FBQ2QsNERBQTREO1FBQzVELElBQUksQ0FBQ0ssS0FBSyxDQUFDMkcsS0FBSyxDQUFDQyxFQUFFLENBQUMsZUFBZSxJQUFJLENBQUN2RSxVQUFVLEVBQUUsSUFBSTtRQUN4RCxJQUFJLENBQUNyQyxLQUFLLENBQUMyRyxLQUFLLENBQUNDLEVBQUUsQ0FBQyxhQUFhLElBQUksQ0FBQzVELFNBQVMsRUFBRSxJQUFJO0lBQ3pEO0FBK1lKO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2dhbWUvY29tcG9uZW50cy9NYXRjaC50cz84NmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdhbWUsIEdhbWVPYmplY3RzLCBTY2VuZSB9IGZyb20gXCJwaGFzZXJcIjtcblxuY2xhc3MgR2Vte1xuICAgIGdlbUNvbG9yOiBzdHJpbmdcbiAgICBnZW1TcHJpdGU6IEdhbWVPYmplY3RzLlNwcml0ZVxuICAgIGlzRW1wdHk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0Y2h7XG5cbiAgICBzY2VuZTogUGhhc2VyLlNjZW5lXG4gICAgc3RhcnRYOiBudW1iZXIgPSAwXG4gICAgc3RhcnRZOiBudW1iZXIgPSAwXG4gICAgLy9cbiAgICBmaWVsZFNpemU6IG51bWJlciA9IDdcbiAgICBnZW1TaXplOiBudW1iZXIgPSAxMjhcbiAgICBzd2FwU3BlZWQ6IG51bWJlciA9IDIwMFxuICAgIGZhbGxTcGVlZDogbnVtYmVyID0gMTAwXG4gICAgZGVzdHJveVNwZWVkOiBudW1iZXIgPSAyMDBcbiAgICBnZW1Db2xvcnM6IHN0cmluZ1tdID0gWydibHVlJywnZ3JlZW4nLCdvcmFuZ2UnLCdyZWQnXVxuICAgIC8vXG4gICAgY2FuUGljazogYm9vbGVhbiA9IHRydWVcbiAgICBkcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG4gICAgLy9cbiAgICBnYW1lQXJyYXk6IGFueSA9IFtdXG4gICAgcG9vbEFycmF5OiBhbnkgPSBbXVxuICAgIGlucHV0QXJyYXk6IGFueSA9IFtdXG4gICAgZ2VtR3JvdXA6IEdhbWVPYmplY3RzLkdyb3VwXG4gICAgLy9cbiAgICBzZWxlY3RlZEdlbTogR2VtIHwgbnVsbFxuICAgIHN3YXBwaW5nR2VtczogbnVtYmVyXG4gICAgcmVtb3ZlTWFwOiBhbnlcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgeDogbnVtYmVyLCB5OiBudW1iZXIpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmVcbiAgICAgICAgLy8gdGhpcy5zdGFydFggPSB4IC0gKHRoaXMuZmllbGRTaXplKnRoaXMuZ2VtU2l6ZSAvMikgXG4gICAgICAgIC8vIHRoaXMuc3RhcnRZID0geSAtICh0aGlzLmZpZWxkU2l6ZSp0aGlzLmdlbVNpemUgLzIpIFxuXG4gICAgICAgIHRoaXMuZHJhd0ZpZWxkKCk7XG4gICAgICAgIC8vIHRoaXMuc2NlbmUuaW5wdXQub24oXCJwb2ludGVyZG93blwiLCB0aGlzLmdlbVNlbGVjdCwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NlbmUuaW5wdXQub24oXCJwb2ludGVybW92ZVwiLCB0aGlzLnN0YXJ0U3dpcGUsIHRoaXMpO1xuICAgICAgICB0aGlzLnNjZW5lLmlucHV0Lm9uKFwicG9pbnRlcnVwXCIsIHRoaXMuc3RvcFN3aXBlLCB0aGlzKTtcbiAgICB9XG5cbiAgICBkcmF3RmllbGQoKXtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5wb29sQXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dEFycmF5ID0gW107XG4gICAgICAgIHRoaXMuZ2VtR3JvdXAgPSB0aGlzLnNjZW5lLmFkZC5ncm91cCgpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRBcnJheVtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKClcblxuICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zdGFydFggKyAodGhpcy5nZW1TaXplICogaiArIHRoaXMuZ2VtU2l6ZSAvIDIpXG4gICAgICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnN0YXJ0WSArICh0aGlzLmdlbVNpemUgKiBpICsgdGhpcy5nZW1TaXplIC8gMilcbiAgICAgICAgICAgICAgICBsZXQgZ2VtID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKCB4ICwgeSwgY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZW1Hcm91cC5hZGQoZ2VtKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgZ2VtRGF0YTogR2VtID0ge1xuICAgICAgICAgICAgICAgICAgICBnZW1Db2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGdlbVNwcml0ZTogZ2VtLFxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXSA9IGdlbURhdGFcblxuICAgICAgICAgICAgICAgIC8vIGxldCBoaXRCb3ggPSB0aGlzLnNjZW5lLmFkZC5yZWN0YW5nbGUoIHgsIHksIHRoaXMuZ2VtU2l6ZSwgdGhpcy5nZW1TaXplLCAweDAwMDAwMCwgMC4yKVxuICAgICAgICAgICAgICAgIC8vIGhpdEJveC5vbihcInBvaW50ZXJkb3duXCIsICggcG9pbnRlcjogUGhhc2VyLklucHV0LlBvaW50ZXIpPT57XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZ2VtU2VsZWN0KHBvaW50ZXIsaSxqKVxuICAgICAgICAgICAgICAgIC8vIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIGhpdEJveC5zZXRJbnRlcmFjdGl2ZSgpXG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLmlucHV0QXJyYXlbaV1bal0gPSBoaXRCb3hcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzTWF0Y2gocm93Om51bWJlciwgY29sOm51bWJlcik6IGJvb2xlYW57XG4gICAgICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbE1hdGNoKHJvdywgY29sKSB8fCB0aGlzLmlzVmVydGljYWxNYXRjaChyb3csIGNvbCk7XG4gICAgfVxuXG4gICAgaXNIb3Jpem9udGFsTWF0Y2gocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93LCBjb2wgLSAxKS5nZW1Db2xvciAmJiB0aGlzLmdlbUF0KHJvdywgY29sKS5nZW1Db2xvciA9PSB0aGlzLmdlbUF0KHJvdywgY29sIC0gMikuZ2VtQ29sb3I7XG4gICAgfVxuXG4gICAgaXNWZXJ0aWNhbE1hdGNoKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IGJvb2xlYW57XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW1BdChyb3csIGNvbCkuZ2VtQ29sb3IgPT0gdGhpcy5nZW1BdChyb3cgLSAxLCBjb2wpLmdlbUNvbG9yICYmIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93IC0gMiwgY29sKS5nZW1Db2xvcjtcbiAgICB9XG4gICAgXG4gICAgZ2VtQXQocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYW55e1xuICAgICAgICBpZihyb3cgPCAwIHx8IHJvdyA+PSB0aGlzLmZpZWxkU2l6ZSB8fCBjb2wgPCAwIHx8IGNvbCA+PSB0aGlzLmZpZWxkU2l6ZSl7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FtZUFycmF5W3Jvd11bY29sXTtcbiAgICB9XG5cbiAgICBnZW1TZWxlY3QocG9pbnRlcjogUGhhc2VyLklucHV0LlBvaW50ZXIsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciApe1xuICAgICAgICBpZih0aGlzLmNhblBpY2spe1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAvLyBsZXQgcm93ID0gTWF0aC5mbG9vcihwb2ludGVyLnkgLyB0aGlzLmdlbVNpemUpO1xuICAgICAgICAgICAgLy8gbGV0IGNvbCA9IE1hdGguZmxvb3IocG9pbnRlci54IC8gdGhpcy5nZW1TaXplKTtcbiAgICAgICAgICAgIGxldCBwaWNrZWRHZW0gPSB0aGlzLmdlbUF0KHJvdywgY29sKVxuICAgICAgICAgICAgaWYocGlja2VkR2VtICE9IC0xKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNlbGVjdGVkR2VtID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBwaWNrZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEuMik7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0RGVwdGgoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBwaWNrZWRHZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJlVGhlU2FtZShwaWNrZWRHZW0sIHRoaXMuc2VsZWN0ZWRHZW0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJlTmV4dChwaWNrZWRHZW0sIHRoaXMuc2VsZWN0ZWRHZW0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN3YXBHZW1zKHRoaXMuc2VsZWN0ZWRHZW0sIHBpY2tlZEdlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMS4yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gcGlja2VkR2VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2VtU2VsZWN0Mihwb2ludGVyOiBQaGFzZXIuSW5wdXQuUG9pbnRlciwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyICl7XG4gICAgICAgIGlmKHRoaXMuY2FuUGljayl7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGxldCByb3cgPSBNYXRoLmZsb29yKHBvaW50ZXIueSAvIHRoaXMuZ2VtU2l6ZSk7XG4gICAgICAgICAgICAvLyBsZXQgY29sID0gTWF0aC5mbG9vcihwb2ludGVyLnggLyB0aGlzLmdlbVNpemUpO1xuICAgICAgICAgICAgbGV0IHBpY2tlZEdlbSA9IHRoaXMuZ2VtQXQocm93LCBjb2wpXG4gICAgICAgICAgICBpZihwaWNrZWRHZW0gIT0gLTEpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2VsZWN0ZWRHZW0gPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMS4yKTtcbiAgICAgICAgICAgICAgICAgICAgcGlja2VkR2VtLmdlbVNwcml0ZS5zZXREZXB0aCgxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IHBpY2tlZEdlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5hcmVUaGVTYW1lKHBpY2tlZEdlbSwgdGhpcy5zZWxlY3RlZEdlbSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5hcmVOZXh0KHBpY2tlZEdlbSwgdGhpcy5zZWxlY3RlZEdlbSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcEdlbXModGhpcy5zZWxlY3RlZEdlbSwgcGlja2VkR2VtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxLjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBwaWNrZWRHZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydFN3aXBlKHBvaW50ZXI6IFBoYXNlci5JbnB1dC5Qb2ludGVyKXtcbiAgICAgICAgaWYodGhpcy5kcmFnZ2luZyAmJiB0aGlzLnNlbGVjdGVkR2VtICE9IG51bGwpe1xuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IHBvaW50ZXIuZG93blggLSBwb2ludGVyLng7XG4gICAgICAgICAgICBsZXQgZGVsdGFZID0gcG9pbnRlci5kb3duWSAtIHBvaW50ZXIueTtcbiAgICAgICAgICAgIGxldCBkZWx0YVJvdyA9IDA7XG4gICAgICAgICAgICBsZXQgZGVsdGFDb2wgPSAwO1xuICAgICAgICAgICAgaWYoZGVsdGFYID4gdGhpcy5nZW1TaXplIC8gMiAmJiBNYXRoLmFicyhkZWx0YVkpIDwgdGhpcy5nZW1TaXplIC8gNCl7XG4gICAgICAgICAgICAgICAgZGVsdGFDb2wgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRlbHRhWCA8IC10aGlzLmdlbVNpemUgLyAyICYmIE1hdGguYWJzKGRlbHRhWSkgPCB0aGlzLmdlbVNpemUgLyA0KXtcbiAgICAgICAgICAgICAgICBkZWx0YUNvbCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWx0YVkgPiB0aGlzLmdlbVNpemUgLyAyICYmIE1hdGguYWJzKGRlbHRhWCkgPCB0aGlzLmdlbVNpemUgLyA0KXtcbiAgICAgICAgICAgICAgICBkZWx0YVJvdyA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVsdGFZIDwgLXRoaXMuZ2VtU2l6ZSAvIDIgJiYgTWF0aC5hYnMoZGVsdGFYKSA8IHRoaXMuZ2VtU2l6ZSAvIDQpe1xuICAgICAgICAgICAgICAgIGRlbHRhUm93ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRlbHRhUm93ICsgZGVsdGFDb2wgIT0gMCl7XG4gICAgICAgICAgICAgICAgbGV0IHBpY2tlZEdlbSA9IHRoaXMuZ2VtQXQodGhpcy5nZXRHZW1Sb3codGhpcy5zZWxlY3RlZEdlbSkgKyBkZWx0YVJvdywgdGhpcy5nZXRHZW1Db2wodGhpcy5zZWxlY3RlZEdlbSkgKyBkZWx0YUNvbCk7XG4gICAgICAgICAgICAgICAgaWYocGlja2VkR2VtICE9IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcEdlbXModGhpcy5zZWxlY3RlZEdlbSwgcGlja2VkR2VtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BTd2lwZSgpe1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYXJlVGhlU2FtZShnZW0xOiBHZW0sIGdlbTI6IEdlbSl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlbVJvdyhnZW0xKSA9PSB0aGlzLmdldEdlbVJvdyhnZW0yKSAmJiB0aGlzLmdldEdlbUNvbChnZW0xKSA9PSB0aGlzLmdldEdlbUNvbChnZW0yKTtcbiAgICB9XG5cbiAgICBnZXRHZW1Sb3coZ2VtOiBHZW0pe1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihnZW0uZ2VtU3ByaXRlLnkgLyB0aGlzLmdlbVNpemUpO1xuICAgIH1cblxuICAgIGdldEdlbUNvbChnZW06IEdlbSl7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGdlbS5nZW1TcHJpdGUueCAvIHRoaXMuZ2VtU2l6ZSk7XG4gICAgfVxuXG4gICAgYXJlTmV4dChnZW0xOiBHZW0sIGdlbTI6IEdlbSl7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmdldEdlbVJvdyhnZW0xKSAtIHRoaXMuZ2V0R2VtUm93KGdlbTIpKSArIE1hdGguYWJzKHRoaXMuZ2V0R2VtQ29sKGdlbTEpIC0gdGhpcy5nZXRHZW1Db2woZ2VtMikpID09IDE7XG4gICAgfVxuXG4gICAgc3dhcEdlbXMoZ2VtMTogR2VtLCBnZW0yOiBHZW0sIHN3YXBCYWNrOiBib29sZWFuKXtcbiAgICAgICAgdGhpcy5zd2FwcGluZ0dlbXMgPSAyO1xuICAgICAgICB0aGlzLmNhblBpY2sgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZyb21Db2xvciA9IGdlbTEuZ2VtQ29sb3I7XG4gICAgICAgIGxldCBmcm9tU3ByaXRlID0gZ2VtMS5nZW1TcHJpdGU7XG4gICAgICAgIGxldCB0b0NvbG9yID0gZ2VtMi5nZW1Db2xvcjtcbiAgICAgICAgbGV0IHRvU3ByaXRlID0gZ2VtMi5nZW1TcHJpdGU7XG4gICAgICAgIGxldCBnZW0xUm93ID0gdGhpcy5nZXRHZW1Sb3coZ2VtMSk7XG4gICAgICAgIGxldCBnZW0xQ29sID0gdGhpcy5nZXRHZW1Db2woZ2VtMSk7XG4gICAgICAgIGxldCBnZW0yUm93ID0gdGhpcy5nZXRHZW1Sb3coZ2VtMik7XG4gICAgICAgIGxldCBnZW0yQ29sID0gdGhpcy5nZXRHZW1Db2woZ2VtMik7XG4gICAgICAgIHRoaXMuZ2FtZUFycmF5W2dlbTFSb3ddW2dlbTFDb2xdLmdlbUNvbG9yID0gdG9Db2xvcjtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXlbZ2VtMVJvd11bZ2VtMUNvbF0uZ2VtU3ByaXRlID0gdG9TcHJpdGU7XG4gICAgICAgIHRoaXMuZ2FtZUFycmF5W2dlbTJSb3ddW2dlbTJDb2xdLmdlbUNvbG9yID0gZnJvbUNvbG9yO1xuICAgICAgICB0aGlzLmdhbWVBcnJheVtnZW0yUm93XVtnZW0yQ29sXS5nZW1TcHJpdGUgPSBmcm9tU3ByaXRlO1xuICAgICAgICB0aGlzLnR3ZWVuR2VtKGdlbTEsIGdlbTIsIHN3YXBCYWNrKTtcbiAgICAgICAgdGhpcy50d2VlbkdlbShnZW0yLCBnZW0xLCBzd2FwQmFjayk7XG4gICAgfVxuXG4gICAgdHdlZW5HZW0oZ2VtMTogR2VtLCBnZW0yOiBHZW0sIHN3YXBCYWNrOiBib29sZWFuKXtcbiAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ2V0R2VtUm93KGdlbTEpO1xuICAgICAgICBsZXQgY29sID0gdGhpcy5nZXRHZW1Db2woZ2VtMSk7XG4gICAgICAgIHRoaXMuc2NlbmUudHdlZW5zLmFkZCh7XG4gICAgICAgICAgICB0YXJnZXRzOiB0aGlzLmdhbWVBcnJheVtyb3ddW2NvbF0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgeDogY29sICogdGhpcy5nZW1TaXplICsgdGhpcy5nZW1TaXplIC8gMixcbiAgICAgICAgICAgIHk6IHJvdyAqIHRoaXMuZ2VtU2l6ZSArIHRoaXMuZ2VtU2l6ZSAvIDIsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5zd2FwU3BlZWQsXG4gICAgICAgICAgICBjYWxsYmFja1Njb3BlOiB0aGlzLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXBwaW5nR2VtcyAtLTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnN3YXBwaW5nR2VtcyA9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMubWF0Y2hJbkJvYXJkKCkgJiYgc3dhcEJhY2spe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwR2VtcyhnZW0xLCBnZW0yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubWF0Y2hJbkJvYXJkKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTWF0Y2hlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblBpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtYXRjaEluQm9hcmQoKXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplOyBpICsrKXtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZTsgaiArKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc01hdGNoKGksIGopKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBoYW5kbGVNYXRjaGVzKCl7XG4gICAgICAgIHRoaXMucmVtb3ZlTWFwID0gW107XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZTsgaSArKyl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1hcFtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1hcFtpXS5wdXNoKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya01hdGNoZXMoJ2hvcml6b250YWwnKTtcbiAgICAgICAgdGhpcy5tYXJrTWF0Y2hlcygndmVydGljYWwnKTtcbiAgICAgICAgdGhpcy5kZXN0cm95R2VtcygpO1xuICAgIH1cblxuICAgIG1hcmtNYXRjaGVzKGRpcmVjdGlvbjogc3RyaW5nKXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplOyBpICsrKXtcbiAgICAgICAgICAgIGxldCBjb2xvclN0cmVhayA9IDE7XG4gICAgICAgICAgICBsZXQgY3VycmVudENvbG9yID0gLTE7XG4gICAgICAgICAgICBsZXQgc3RhcnRTdHJlYWsgPSAwO1xuICAgICAgICAgICAgbGV0IGNvbG9yVG9XYXRjaCA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemU7IGogKyspe1xuICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpe1xuICAgICAgICAgICAgICAgICAgICBjb2xvclRvV2F0Y2ggPSB0aGlzLmdlbUF0KGksIGopLmdlbUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBjb2xvclRvV2F0Y2ggPSB0aGlzLmdlbUF0KGosIGkpLmdlbUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihjb2xvclRvV2F0Y2ggPT0gY3VycmVudENvbG9yKXtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JTdHJlYWsgKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGNvbG9yVG9XYXRjaCAhPSBjdXJyZW50Q29sb3IgfHwgaiA9PSB0aGlzLmZpZWxkU2l6ZSAtIDEpe1xuICAgICAgICAgICAgICAgICAgICBpZihjb2xvclN0cmVhayA+PSAzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSE9SSVpPTlRBTCA6OiBMZW5ndGggPSBcIiArIGNvbG9yU3RyZWFrICsgXCIgOjogU3RhcnQgPSAoXCIgKyBpICsgXCIsXCIgKyBzdGFydFN0cmVhayArIFwiKSA6OiBDb2xvciA9IFwiICsgY3VycmVudENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWRVJUSUNBTCA6OiBMZW5ndGggPSBcIiArIGNvbG9yU3RyZWFrICsgXCIgOjogU3RhcnQgPSAoXCIgKyBzdGFydFN0cmVhayArIFwiLFwiICsgaSArIFwiKSA6OiBDb2xvciA9IFwiICsgY3VycmVudENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgayA9IDA7IGsgPCBjb2xvclN0cmVhazsgayArKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwW2ldW3N0YXJ0U3RyZWFrICsga10gKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwW3N0YXJ0U3RyZWFrICsga11baV0gKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U3RyZWFrID0gajtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JTdHJlYWsgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29sb3IgPSBjb2xvclRvV2F0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveUdlbXMoKXtcbiAgICAgICAgbGV0IGRlc3Ryb3llZCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZTsgaSArKyl7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemU7IGogKyspe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMucmVtb3ZlTWFwW2ldW2pdID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llZCArKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50d2VlbnMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kZXN0cm95U3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1Njb3BlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZWQgLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2xBcnJheS5wdXNoKHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVzdHJveWVkID09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VHZW1zRmFsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxlbmlzaEZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZUdlbXNGYWxsKCl7XG4gICAgICAgIGZvcihsZXQgaSA9IHRoaXMuZmllbGRTaXplIC0gMjsgaSA+PSAwOyBpIC0tKXtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZTsgaiArKyl7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuZ2FtZUFycmF5W2ldW2pdLmlzRW1wdHkpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFsbFRpbGVzID0gdGhpcy5ob2xlc0JlbG93KGksIGopO1xuICAgICAgICAgICAgICAgICAgICBpZihmYWxsVGlsZXMgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudHdlZW5zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS55ICsgZmFsbFRpbGVzICogdGhpcy5nZW1TaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmZhbGxTcGVlZCAqIGZhbGxUaWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpICsgZmFsbFRpbGVzXVtqXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW1TcHJpdGU6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW1Db2xvcjogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFbXB0eTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmlzRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9sZXNCZWxvdyhyb3c6IG51bWJlciwgY29sOiBudW1iZXIpe1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gcm93ICsgMTsgaSA8IHRoaXMuZmllbGRTaXplOyBpICsrKXtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2FtZUFycmF5W2ldW2NvbF0uaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVwbGVuaXNoRmllbGQoKXtcbiAgICAgICAgbGV0IHJlcGxlbmlzaGVkID0gMDtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgIGxldCBlbXB0eVNwb3RzID0gdGhpcy5ob2xlc0luQ29sKGopO1xuICAgICAgICAgICAgaWYoZW1wdHlTcG90cyA+IDApe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbXB0eVNwb3RzOyBpICsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoZWQgKys7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5kb21Db2xvciA9IHRoaXMucmFuZG9tQ29sb3IoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1Db2xvciA9IHJhbmRvbUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUgPSB0aGlzLnBvb2xBcnJheS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUuc2V0VGV4dHVyZShyYW5kb21Db2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnggPSB0aGlzLmdlbVNpemUgKiBqICsgdGhpcy5nZW1TaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnkgPSB0aGlzLmdlbVNpemUgLyAyIC0gKGVtcHR5U3BvdHMgLSBpKSAqIHRoaXMuZ2VtU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLmFscGhhID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5nZW1TaXplICogaSArIHRoaXMuZ2VtU2l6ZSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5mYWxsU3BlZWQgKiBlbXB0eVNwb3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoZWQgLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVwbGVuaXNoZWQgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubWF0Y2hJbkJvYXJkKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50aW1lLmFkZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogMjUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLmhhbmRsZU1hdGNoZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9sZXNJbkNvbChjb2w6IG51bWJlcil7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgaWYodGhpcy5nYW1lQXJyYXlbaV1bY29sXS5pc0VtcHR5KXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByYW5kb21Db2xvcigpOnN0cmluZ3tcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VtQ29sb3JzW1BoYXNlci5NYXRoLkJldHdlZW4oMCwgdGhpcy5nZW1Db2xvcnMubGVuZ3RoIC0gMSldO1xuICAgIH1cbn0iXSwibmFtZXMiOlsiR2VtIiwiTWF0Y2giLCJkcmF3RmllbGQiLCJnYW1lQXJyYXkiLCJwb29sQXJyYXkiLCJpbnB1dEFycmF5IiwiZ2VtR3JvdXAiLCJzY2VuZSIsImFkZCIsImdyb3VwIiwiaSIsImZpZWxkU2l6ZSIsImoiLCJjb2xvciIsInJhbmRvbUNvbG9yIiwieCIsInN0YXJ0WCIsImdlbVNpemUiLCJ5Iiwic3RhcnRZIiwiZ2VtIiwic3ByaXRlIiwiZ2VtRGF0YSIsImdlbUNvbG9yIiwiZ2VtU3ByaXRlIiwiaXNFbXB0eSIsImlzTWF0Y2giLCJyb3ciLCJjb2wiLCJpc0hvcml6b250YWxNYXRjaCIsImlzVmVydGljYWxNYXRjaCIsImdlbUF0IiwiZ2VtU2VsZWN0IiwicG9pbnRlciIsImNhblBpY2siLCJkcmFnZ2luZyIsInBpY2tlZEdlbSIsInNlbGVjdGVkR2VtIiwic2V0U2NhbGUiLCJzZXREZXB0aCIsImFyZVRoZVNhbWUiLCJhcmVOZXh0Iiwic3dhcEdlbXMiLCJnZW1TZWxlY3QyIiwic3RhcnRTd2lwZSIsImRlbHRhWCIsImRvd25YIiwiZGVsdGFZIiwiZG93blkiLCJkZWx0YVJvdyIsImRlbHRhQ29sIiwiTWF0aCIsImFicyIsImdldEdlbVJvdyIsImdldEdlbUNvbCIsInN0b3BTd2lwZSIsImdlbTEiLCJnZW0yIiwiZmxvb3IiLCJzd2FwQmFjayIsInN3YXBwaW5nR2VtcyIsImZyb21Db2xvciIsImZyb21TcHJpdGUiLCJ0b0NvbG9yIiwidG9TcHJpdGUiLCJnZW0xUm93IiwiZ2VtMUNvbCIsImdlbTJSb3ciLCJnZW0yQ29sIiwidHdlZW5HZW0iLCJ0d2VlbnMiLCJ0YXJnZXRzIiwiZHVyYXRpb24iLCJzd2FwU3BlZWQiLCJjYWxsYmFja1Njb3BlIiwib25Db21wbGV0ZSIsIm1hdGNoSW5Cb2FyZCIsImhhbmRsZU1hdGNoZXMiLCJyZW1vdmVNYXAiLCJwdXNoIiwibWFya01hdGNoZXMiLCJkZXN0cm95R2VtcyIsImRpcmVjdGlvbiIsImNvbG9yU3RyZWFrIiwiY3VycmVudENvbG9yIiwic3RhcnRTdHJlYWsiLCJjb2xvclRvV2F0Y2giLCJjb25zb2xlIiwibG9nIiwiayIsImRlc3Ryb3llZCIsImFscGhhIiwiZGVzdHJveVNwZWVkIiwidmlzaWJsZSIsIm1ha2VHZW1zRmFsbCIsInJlcGxlbmlzaEZpZWxkIiwiZmFsbFRpbGVzIiwiaG9sZXNCZWxvdyIsImZhbGxTcGVlZCIsInJlc3VsdCIsInJlcGxlbmlzaGVkIiwiZW1wdHlTcG90cyIsImhvbGVzSW5Db2wiLCJwb3AiLCJzZXRUZXh0dXJlIiwidGltZSIsImFkZEV2ZW50IiwiZGVsYXkiLCJjYWxsYmFjayIsImdlbUNvbG9ycyIsIlBoYXNlciIsIkJldHdlZW4iLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsImlucHV0Iiwib24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/game/components/Match.ts\n"));

/***/ })

});