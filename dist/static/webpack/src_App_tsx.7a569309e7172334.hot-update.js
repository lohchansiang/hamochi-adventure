"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_App_tsx",{

/***/ "./src/game/components/Match.ts":
/*!**************************************!*\
  !*** ./src/game/components/Match.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Match; }\n/* harmony export */ });\nclass Gem {\n}\nclass Match {\n    drawField() {\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.gemGroup = this.scene.add.group();\n        for(let i = 0; i < this.fieldSize; i++){\n            this.gameArray[i] = [];\n            this.inputArray[i] = [];\n            for(let j = 0; j < this.fieldSize; j++){\n                let color = this.randomColor();\n                let x = this.startX + (this.gemSize * j + this.gemSize / 2);\n                let y = this.startY + (this.gemSize * i + this.gemSize / 2);\n                let gem = this.scene.add.sprite(x, y, color);\n                this.gemGroup.add(gem);\n                let gemData = {\n                    gemColor: color,\n                    gemSprite: gem,\n                    isEmpty: false\n                };\n                this.gameArray[i][j] = gemData;\n                let hitBox = this.scene.add.rectangle(x, y, this.gemSize, this.gemSize, 0x000000, 0.2);\n                hitBox.on(\"pointerdown\", (pointer)=>{\n                    this.gemSelect(pointer, i, j);\n                }, this);\n                hitBox.setInteractive();\n                this.inputArray[i][j] = hitBox;\n            }\n        }\n    }\n    isMatch(row, col) {\n        return this.isHorizontalMatch(row, col) || this.isVerticalMatch(row, col);\n    }\n    isHorizontalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row, col - 1).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row, col - 2).gemColor;\n    }\n    isVerticalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row - 1, col).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row - 2, col).gemColor;\n    }\n    gemAt(row, col) {\n        if (row < 0 || row >= this.fieldSize || col < 0 || col >= this.fieldSize) {\n            return -1;\n        }\n        return this.gameArray[row][col];\n    }\n    gemSelect(pointer, row, col) {\n        if (this.canPick) {\n            this.dragging = true;\n            // let row = Math.floor(pointer.y / this.gemSize);\n            // let col = Math.floor(pointer.x / this.gemSize);\n            let pickedGem = this.gemAt(row, col);\n            if (pickedGem != -1) {\n                if (this.selectedGem == null) {\n                    pickedGem.gemSprite.setScale(1.2);\n                    pickedGem.gemSprite.setDepth(1);\n                    this.selectedGem = pickedGem;\n                    this.selectedRow = row;\n                    this.selectedCol = col;\n                } else {\n                    if (this.areTheSame(pickedGem, this.selectedGem)) {\n                        this.selectedGem.gemSprite.setScale(1);\n                        this.selectedGem = null;\n                    } else {\n                        if (this.areNext(pickedGem, this.selectedGem)) {\n                            this.selectedGem.gemSprite.setScale(1);\n                            this.swapGems(this.selectedGem, pickedGem, true);\n                        } else {\n                            this.selectedGem.gemSprite.setScale(1);\n                            pickedGem.gemSprite.setScale(1.2);\n                            this.selectedGem = pickedGem;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    startSwipe(pointer) {\n        if (this.dragging && this.selectedGem != null) {\n            let deltaX = pointer.downX - pointer.x;\n            let deltaY = pointer.downY - pointer.y;\n            let deltaRow = 0;\n            let deltaCol = 0;\n            if (deltaX > this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = -1;\n            }\n            if (deltaX < -this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = 1;\n            }\n            if (deltaY > this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = -1;\n            }\n            if (deltaY < -this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = 1;\n            }\n            if (deltaRow + deltaCol != 0) {\n                let pickedGem = this.gemAt(this.getGemRow(this.selectedGem) + deltaRow, this.getGemCol(this.selectedGem) + deltaCol);\n                if (pickedGem != -1) {\n                    this.selectedGem.gemSprite.setScale(1);\n                    this.swapGems(this.selectedGem, pickedGem, true);\n                    this.dragging = false;\n                }\n            }\n        }\n    }\n    stopSwipe() {\n        this.dragging = false;\n    }\n    areTheSame(gem1, gem2) {\n        return this.getGemRow(gem1) == this.getGemRow(gem2) && this.getGemCol(gem1) == this.getGemCol(gem2);\n    }\n    getGemRow(gem) {\n        return Math.floor(gem.gemSprite.y / this.gemSize);\n    }\n    getGemCol(gem) {\n        return Math.floor(gem.gemSprite.x / this.gemSize);\n    }\n    areNext(gem1, gem2) {\n        return Math.abs(this.getGemRow(gem1) - this.getGemRow(gem2)) + Math.abs(this.getGemCol(gem1) - this.getGemCol(gem2)) == 1;\n    }\n    swapGems(gem1, gem2, swapBack) {\n        this.swappingGems = 2;\n        this.canPick = false;\n        let fromColor = gem1.gemColor;\n        let fromSprite = gem1.gemSprite;\n        let toColor = gem2.gemColor;\n        let toSprite = gem2.gemSprite;\n        let gem1Row = this.getGemRow(gem1);\n        let gem1Col = this.getGemCol(gem1);\n        let gem2Row = this.getGemRow(gem2);\n        let gem2Col = this.getGemCol(gem2);\n        this.gameArray[gem1Row][gem1Col].gemColor = toColor;\n        this.gameArray[gem1Row][gem1Col].gemSprite = toSprite;\n        this.gameArray[gem2Row][gem2Col].gemColor = fromColor;\n        this.gameArray[gem2Row][gem2Col].gemSprite = fromSprite;\n        this.tweenGem(gem1, gem2, swapBack);\n        this.tweenGem(gem2, gem1, swapBack);\n    }\n    tweenGem(gem1, gem2, swapBack) {\n        let row = this.getGemRow(gem1);\n        let col = this.getGemCol(gem1);\n        this.scene.tweens.add({\n            targets: this.gameArray[row][col].gemSprite,\n            x: col * this.gemSize + this.gemSize / 2,\n            y: row * this.gemSize + this.gemSize / 2,\n            duration: this.swapSpeed,\n            callbackScope: this,\n            onComplete: function() {\n                this.swappingGems--;\n                if (this.swappingGems == 0) {\n                    if (!this.matchInBoard() && swapBack) {\n                        this.swapGems(gem1, gem2, false);\n                    } else {\n                        if (this.matchInBoard()) {\n                            this.handleMatches();\n                        } else {\n                            this.canPick = true;\n                            this.selectedGem = null;\n                        }\n                    }\n                }\n            }\n        });\n    }\n    matchInBoard() {\n        for(let i = 0; i < this.fieldSize; i++){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (this.isMatch(i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    handleMatches() {\n        this.removeMap = [];\n        for(let i = 0; i < this.fieldSize; i++){\n            this.removeMap[i] = [];\n            for(let j = 0; j < this.fieldSize; j++){\n                this.removeMap[i].push(0);\n            }\n        }\n        this.markMatches(\"horizontal\");\n        this.markMatches(\"vertical\");\n        this.destroyGems();\n    }\n    markMatches(direction) {\n        for(let i = 0; i < this.fieldSize; i++){\n            let colorStreak = 1;\n            let currentColor = -1;\n            let startStreak = 0;\n            let colorToWatch = 0;\n            for(let j = 0; j < this.fieldSize; j++){\n                if (direction == \"horizontal\") {\n                    colorToWatch = this.gemAt(i, j).gemColor;\n                } else {\n                    colorToWatch = this.gemAt(j, i).gemColor;\n                }\n                if (colorToWatch == currentColor) {\n                    colorStreak++;\n                }\n                if (colorToWatch != currentColor || j == this.fieldSize - 1) {\n                    if (colorStreak >= 3) {\n                        if (direction == \"horizontal\") {\n                            console.log(\"HORIZONTAL :: Length = \" + colorStreak + \" :: Start = (\" + i + \",\" + startStreak + \") :: Color = \" + currentColor);\n                        } else {\n                            console.log(\"VERTICAL :: Length = \" + colorStreak + \" :: Start = (\" + startStreak + \",\" + i + \") :: Color = \" + currentColor);\n                        }\n                        for(let k = 0; k < colorStreak; k++){\n                            if (direction == \"horizontal\") {\n                                this.removeMap[i][startStreak + k]++;\n                            } else {\n                                this.removeMap[startStreak + k][i]++;\n                            }\n                        }\n                    }\n                    startStreak = j;\n                    colorStreak = 1;\n                    currentColor = colorToWatch;\n                }\n            }\n        }\n    }\n    destroyGems() {\n        let destroyed = 0;\n        for(let i = 0; i < this.fieldSize; i++){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (this.removeMap[i][j] > 0) {\n                    destroyed++;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        alpha: 0.5,\n                        duration: this.destroySpeed,\n                        callbackScope: this,\n                        onComplete: function() {\n                            destroyed--;\n                            this.gameArray[i][j].gemSprite.visible = false;\n                            this.poolArray.push(this.gameArray[i][j].gemSprite);\n                            if (destroyed == 0) {\n                                this.makeGemsFall();\n                                this.replenishField();\n                            }\n                        }\n                    });\n                    this.gameArray[i][j].isEmpty = true;\n                }\n            }\n        }\n    }\n    makeGemsFall() {\n        for(let i = this.fieldSize - 2; i >= 0; i--){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (!this.gameArray[i][j].isEmpty) {\n                    let fallTiles = this.holesBelow(i, j);\n                    if (fallTiles > 0) {\n                        this.scene.tweens.add({\n                            targets: this.gameArray[i][j].gemSprite,\n                            y: this.gameArray[i][j].gemSprite.y + fallTiles * this.gemSize,\n                            duration: this.fallSpeed * fallTiles\n                        });\n                        this.gameArray[i + fallTiles][j] = {\n                            gemSprite: this.gameArray[i][j].gemSprite,\n                            gemColor: this.gameArray[i][j].gemColor,\n                            isEmpty: false\n                        };\n                        this.gameArray[i][j].isEmpty = true;\n                    }\n                }\n            }\n        }\n    }\n    holesBelow(row, col) {\n        let result = 0;\n        for(let i = row + 1; i < this.fieldSize; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    replenishField() {\n        let replenished = 0;\n        for(let j = 0; j < this.fieldSize; j++){\n            let emptySpots = this.holesInCol(j);\n            if (emptySpots > 0) {\n                for(let i = 0; i < emptySpots; i++){\n                    replenished++;\n                    let randomColor = this.randomColor();\n                    this.gameArray[i][j].gemColor = randomColor;\n                    this.gameArray[i][j].gemSprite = this.poolArray.pop();\n                    this.gameArray[i][j].gemSprite.setTexture(randomColor);\n                    this.gameArray[i][j].gemSprite.visible = true;\n                    this.gameArray[i][j].gemSprite.x = this.gemSize * j + this.gemSize / 2;\n                    this.gameArray[i][j].gemSprite.y = this.gemSize / 2 - (emptySpots - i) * this.gemSize;\n                    this.gameArray[i][j].gemSprite.alpha = 1;\n                    this.gameArray[i][j].isEmpty = false;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        y: this.gemSize * i + this.gemSize / 2,\n                        duration: this.fallSpeed * emptySpots,\n                        callbackScope: this,\n                        onComplete: function() {\n                            replenished--;\n                            if (replenished == 0) {\n                                if (this.matchInBoard()) {\n                                    this.scene.time.addEvent({\n                                        delay: 250,\n                                        callback: this.handleMatches()\n                                    });\n                                } else {\n                                    this.canPick = true;\n                                    this.selectedGem = null;\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n    holesInCol(col) {\n        var result = 0;\n        for(let i = 0; i < this.fieldSize; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    randomColor() {\n        return this.gemColors[Phaser.Math.Between(0, this.gemColors.length - 1)];\n    }\n    constructor(scene, x, y){\n        this.startX = 0;\n        this.startY = 0;\n        //\n        this.fieldSize = 7;\n        this.gemSize = 128;\n        this.swapSpeed = 200;\n        this.fallSpeed = 100;\n        this.destroySpeed = 200;\n        this.gemColors = [\n            \"blue\",\n            \"green\",\n            \"orange\",\n            \"red\"\n        ];\n        //\n        this.canPick = true;\n        this.dragging = false;\n        //\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.scene = scene;\n        // this.startX = x - (this.fieldSize*this.gemSize /2) \n        // this.startY = y - (this.fieldSize*this.gemSize /2) \n        this.drawField();\n        // this.scene.input.on(\"pointerdown\", this.gemSelect, this);\n        this.scene.input.on(\"pointermove\", this.startSwipe, this);\n        this.scene.input.on(\"pointerup\", this.stopSwipe, this);\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bXBvbmVudHMvTWF0Y2gudHM/ODZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHYW1lLCBHYW1lT2JqZWN0cywgU2NlbmUgfSBmcm9tIFwicGhhc2VyXCI7XG5cbmNsYXNzIEdlbXtcbiAgICBnZW1Db2xvcjogc3RyaW5nXG4gICAgZ2VtU3ByaXRlOiBHYW1lT2JqZWN0cy5TcHJpdGVcbiAgICBpc0VtcHR5OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGNoe1xuXG4gICAgc2NlbmU6IFBoYXNlci5TY2VuZVxuICAgIHN0YXJ0WDogbnVtYmVyID0gMFxuICAgIHN0YXJ0WTogbnVtYmVyID0gMFxuICAgIC8vXG4gICAgZmllbGRTaXplOiBudW1iZXIgPSA3XG4gICAgZ2VtU2l6ZTogbnVtYmVyID0gMTI4XG4gICAgc3dhcFNwZWVkOiBudW1iZXIgPSAyMDBcbiAgICBmYWxsU3BlZWQ6IG51bWJlciA9IDEwMFxuICAgIGRlc3Ryb3lTcGVlZDogbnVtYmVyID0gMjAwXG4gICAgZ2VtQ29sb3JzOiBzdHJpbmdbXSA9IFsnYmx1ZScsJ2dyZWVuJywnb3JhbmdlJywncmVkJ11cbiAgICAvL1xuICAgIGNhblBpY2s6IGJvb2xlYW4gPSB0cnVlXG4gICAgZHJhZ2dpbmc6IGJvb2xlYW4gPSBmYWxzZVxuICAgIC8vXG4gICAgZ2FtZUFycmF5OiBhbnkgPSBbXVxuICAgIHBvb2xBcnJheTogYW55ID0gW11cbiAgICBpbnB1dEFycmF5OiBhbnkgPSBbXVxuICAgIGdlbUdyb3VwOiBHYW1lT2JqZWN0cy5Hcm91cFxuICAgIC8vXG4gICAgc2VsZWN0ZWRHZW06IEdlbSB8IG51bGxcbiAgICBzZWxlY3RlZFJvdzogbnVtYmVyXG4gICAgc2VsZWN0ZWRDb2w6IG51bWJlclxuICAgIHN3YXBwaW5nR2VtczogbnVtYmVyXG4gICAgcmVtb3ZlTWFwOiBhbnlcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgeDogbnVtYmVyLCB5OiBudW1iZXIpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmVcbiAgICAgICAgLy8gdGhpcy5zdGFydFggPSB4IC0gKHRoaXMuZmllbGRTaXplKnRoaXMuZ2VtU2l6ZSAvMikgXG4gICAgICAgIC8vIHRoaXMuc3RhcnRZID0geSAtICh0aGlzLmZpZWxkU2l6ZSp0aGlzLmdlbVNpemUgLzIpIFxuXG4gICAgICAgIHRoaXMuZHJhd0ZpZWxkKCk7XG4gICAgICAgIC8vIHRoaXMuc2NlbmUuaW5wdXQub24oXCJwb2ludGVyZG93blwiLCB0aGlzLmdlbVNlbGVjdCwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NlbmUuaW5wdXQub24oXCJwb2ludGVybW92ZVwiLCB0aGlzLnN0YXJ0U3dpcGUsIHRoaXMpO1xuICAgICAgICB0aGlzLnNjZW5lLmlucHV0Lm9uKFwicG9pbnRlcnVwXCIsIHRoaXMuc3RvcFN3aXBlLCB0aGlzKTtcbiAgICB9XG5cbiAgICBkcmF3RmllbGQoKXtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5wb29sQXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dEFycmF5ID0gW107XG4gICAgICAgIHRoaXMuZ2VtR3JvdXAgPSB0aGlzLnNjZW5lLmFkZC5ncm91cCgpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRBcnJheVtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKClcblxuICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zdGFydFggKyAodGhpcy5nZW1TaXplICogaiArIHRoaXMuZ2VtU2l6ZSAvIDIpXG4gICAgICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnN0YXJ0WSArICh0aGlzLmdlbVNpemUgKiBpICsgdGhpcy5nZW1TaXplIC8gMilcbiAgICAgICAgICAgICAgICBsZXQgZ2VtID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKCB4ICwgeSwgY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZW1Hcm91cC5hZGQoZ2VtKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgZ2VtRGF0YTogR2VtID0ge1xuICAgICAgICAgICAgICAgICAgICBnZW1Db2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGdlbVNwcml0ZTogZ2VtLFxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXSA9IGdlbURhdGFcblxuICAgICAgICAgICAgICAgIGxldCBoaXRCb3ggPSB0aGlzLnNjZW5lLmFkZC5yZWN0YW5nbGUoIHgsIHksIHRoaXMuZ2VtU2l6ZSwgdGhpcy5nZW1TaXplLCAweDAwMDAwMCwgMC4yKVxuICAgICAgICAgICAgICAgIGhpdEJveC5vbihcInBvaW50ZXJkb3duXCIsICggcG9pbnRlcjogUGhhc2VyLklucHV0LlBvaW50ZXIpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VtU2VsZWN0KHBvaW50ZXIsaSxqKVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIGhpdEJveC5zZXRJbnRlcmFjdGl2ZSgpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0QXJyYXlbaV1bal0gPSBoaXRCb3hcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzTWF0Y2gocm93Om51bWJlciwgY29sOm51bWJlcik6IGJvb2xlYW57XG4gICAgICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbE1hdGNoKHJvdywgY29sKSB8fCB0aGlzLmlzVmVydGljYWxNYXRjaChyb3csIGNvbCk7XG4gICAgfVxuXG4gICAgaXNIb3Jpem9udGFsTWF0Y2gocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93LCBjb2wgLSAxKS5nZW1Db2xvciAmJiB0aGlzLmdlbUF0KHJvdywgY29sKS5nZW1Db2xvciA9PSB0aGlzLmdlbUF0KHJvdywgY29sIC0gMikuZ2VtQ29sb3I7XG4gICAgfVxuXG4gICAgaXNWZXJ0aWNhbE1hdGNoKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IGJvb2xlYW57XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW1BdChyb3csIGNvbCkuZ2VtQ29sb3IgPT0gdGhpcy5nZW1BdChyb3cgLSAxLCBjb2wpLmdlbUNvbG9yICYmIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93IC0gMiwgY29sKS5nZW1Db2xvcjtcbiAgICB9XG4gICAgXG4gICAgZ2VtQXQocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYW55e1xuICAgICAgICBpZihyb3cgPCAwIHx8IHJvdyA+PSB0aGlzLmZpZWxkU2l6ZSB8fCBjb2wgPCAwIHx8IGNvbCA+PSB0aGlzLmZpZWxkU2l6ZSl7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FtZUFycmF5W3Jvd11bY29sXTtcbiAgICB9XG5cbiAgICBnZW1TZWxlY3QocG9pbnRlcjogUGhhc2VyLklucHV0LlBvaW50ZXIsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciApe1xuICAgICAgICBpZih0aGlzLmNhblBpY2spe1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAvLyBsZXQgcm93ID0gTWF0aC5mbG9vcihwb2ludGVyLnkgLyB0aGlzLmdlbVNpemUpO1xuICAgICAgICAgICAgLy8gbGV0IGNvbCA9IE1hdGguZmxvb3IocG9pbnRlci54IC8gdGhpcy5nZW1TaXplKTtcbiAgICAgICAgICAgIGxldCBwaWNrZWRHZW0gPSB0aGlzLmdlbUF0KHJvdywgY29sKVxuICAgICAgICAgICAgaWYocGlja2VkR2VtICE9IC0xKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNlbGVjdGVkR2VtID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBwaWNrZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEuMik7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0RGVwdGgoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBwaWNrZWRHZW07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSb3cgPSByb3dcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZENvbCA9IGNvbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmFyZVRoZVNhbWUocGlja2VkR2VtLCB0aGlzLnNlbGVjdGVkR2VtKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmFyZU5leHQocGlja2VkR2VtLCB0aGlzLnNlbGVjdGVkR2VtKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwR2Vtcyh0aGlzLnNlbGVjdGVkR2VtLCBwaWNrZWRHZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IHBpY2tlZEdlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0U3dpcGUocG9pbnRlcjogUGhhc2VyLklucHV0LlBvaW50ZXIpe1xuICAgICAgICBpZih0aGlzLmRyYWdnaW5nICYmIHRoaXMuc2VsZWN0ZWRHZW0gIT0gbnVsbCl7XG4gICAgICAgICAgICBsZXQgZGVsdGFYID0gcG9pbnRlci5kb3duWCAtIHBvaW50ZXIueDtcbiAgICAgICAgICAgIGxldCBkZWx0YVkgPSBwb2ludGVyLmRvd25ZIC0gcG9pbnRlci55O1xuICAgICAgICAgICAgbGV0IGRlbHRhUm93ID0gMDtcbiAgICAgICAgICAgIGxldCBkZWx0YUNvbCA9IDA7XG4gICAgICAgICAgICBpZihkZWx0YVggPiB0aGlzLmdlbVNpemUgLyAyICYmIE1hdGguYWJzKGRlbHRhWSkgPCB0aGlzLmdlbVNpemUgLyA0KXtcbiAgICAgICAgICAgICAgICBkZWx0YUNvbCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVsdGFYIDwgLXRoaXMuZ2VtU2l6ZSAvIDIgJiYgTWF0aC5hYnMoZGVsdGFZKSA8IHRoaXMuZ2VtU2l6ZSAvIDQpe1xuICAgICAgICAgICAgICAgIGRlbHRhQ29sID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRlbHRhWSA+IHRoaXMuZ2VtU2l6ZSAvIDIgJiYgTWF0aC5hYnMoZGVsdGFYKSA8IHRoaXMuZ2VtU2l6ZSAvIDQpe1xuICAgICAgICAgICAgICAgIGRlbHRhUm93ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWx0YVkgPCAtdGhpcy5nZW1TaXplIC8gMiAmJiBNYXRoLmFicyhkZWx0YVgpIDwgdGhpcy5nZW1TaXplIC8gNCl7XG4gICAgICAgICAgICAgICAgZGVsdGFSb3cgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVsdGFSb3cgKyBkZWx0YUNvbCAhPSAwKXtcbiAgICAgICAgICAgICAgICBsZXQgcGlja2VkR2VtID0gdGhpcy5nZW1BdCh0aGlzLmdldEdlbVJvdyh0aGlzLnNlbGVjdGVkR2VtKSArIGRlbHRhUm93LCB0aGlzLmdldEdlbUNvbCh0aGlzLnNlbGVjdGVkR2VtKSArIGRlbHRhQ29sKTtcbiAgICAgICAgICAgICAgICBpZihwaWNrZWRHZW0gIT0gLTEpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwR2Vtcyh0aGlzLnNlbGVjdGVkR2VtLCBwaWNrZWRHZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcFN3aXBlKCl7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBhcmVUaGVTYW1lKGdlbTE6IEdlbSwgZ2VtMjogR2VtKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VtUm93KGdlbTEpID09IHRoaXMuZ2V0R2VtUm93KGdlbTIpICYmIHRoaXMuZ2V0R2VtQ29sKGdlbTEpID09IHRoaXMuZ2V0R2VtQ29sKGdlbTIpO1xuICAgIH1cblxuICAgIGdldEdlbVJvdyhnZW06IEdlbSl7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGdlbS5nZW1TcHJpdGUueSAvIHRoaXMuZ2VtU2l6ZSk7XG4gICAgfVxuXG4gICAgZ2V0R2VtQ29sKGdlbTogR2VtKXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZ2VtLmdlbVNwcml0ZS54IC8gdGhpcy5nZW1TaXplKTtcbiAgICB9XG5cbiAgICBhcmVOZXh0KGdlbTE6IEdlbSwgZ2VtMjogR2VtKXtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0R2VtUm93KGdlbTEpIC0gdGhpcy5nZXRHZW1Sb3coZ2VtMikpICsgTWF0aC5hYnModGhpcy5nZXRHZW1Db2woZ2VtMSkgLSB0aGlzLmdldEdlbUNvbChnZW0yKSkgPT0gMTtcbiAgICB9XG5cbiAgICBzd2FwR2VtcyhnZW0xOiBHZW0sIGdlbTI6IEdlbSwgc3dhcEJhY2s6IGJvb2xlYW4pe1xuICAgICAgICB0aGlzLnN3YXBwaW5nR2VtcyA9IDI7XG4gICAgICAgIHRoaXMuY2FuUGljayA9IGZhbHNlO1xuICAgICAgICBsZXQgZnJvbUNvbG9yID0gZ2VtMS5nZW1Db2xvcjtcbiAgICAgICAgbGV0IGZyb21TcHJpdGUgPSBnZW0xLmdlbVNwcml0ZTtcbiAgICAgICAgbGV0IHRvQ29sb3IgPSBnZW0yLmdlbUNvbG9yO1xuICAgICAgICBsZXQgdG9TcHJpdGUgPSBnZW0yLmdlbVNwcml0ZTtcbiAgICAgICAgbGV0IGdlbTFSb3cgPSB0aGlzLmdldEdlbVJvdyhnZW0xKTtcbiAgICAgICAgbGV0IGdlbTFDb2wgPSB0aGlzLmdldEdlbUNvbChnZW0xKTtcbiAgICAgICAgbGV0IGdlbTJSb3cgPSB0aGlzLmdldEdlbVJvdyhnZW0yKTtcbiAgICAgICAgbGV0IGdlbTJDb2wgPSB0aGlzLmdldEdlbUNvbChnZW0yKTtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXlbZ2VtMVJvd11bZ2VtMUNvbF0uZ2VtQ29sb3IgPSB0b0NvbG9yO1xuICAgICAgICB0aGlzLmdhbWVBcnJheVtnZW0xUm93XVtnZW0xQ29sXS5nZW1TcHJpdGUgPSB0b1Nwcml0ZTtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXlbZ2VtMlJvd11bZ2VtMkNvbF0uZ2VtQ29sb3IgPSBmcm9tQ29sb3I7XG4gICAgICAgIHRoaXMuZ2FtZUFycmF5W2dlbTJSb3ddW2dlbTJDb2xdLmdlbVNwcml0ZSA9IGZyb21TcHJpdGU7XG4gICAgICAgIHRoaXMudHdlZW5HZW0oZ2VtMSwgZ2VtMiwgc3dhcEJhY2spO1xuICAgICAgICB0aGlzLnR3ZWVuR2VtKGdlbTIsIGdlbTEsIHN3YXBCYWNrKTtcbiAgICB9XG5cbiAgICB0d2VlbkdlbShnZW0xOiBHZW0sIGdlbTI6IEdlbSwgc3dhcEJhY2s6IGJvb2xlYW4pe1xuICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRHZW1Sb3coZ2VtMSk7XG4gICAgICAgIGxldCBjb2wgPSB0aGlzLmdldEdlbUNvbChnZW0xKTtcbiAgICAgICAgdGhpcy5zY2VuZS50d2VlbnMuYWRkKHtcbiAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZ2FtZUFycmF5W3Jvd11bY29sXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICB4OiBjb2wgKiB0aGlzLmdlbVNpemUgKyB0aGlzLmdlbVNpemUgLyAyLFxuICAgICAgICAgICAgeTogcm93ICogdGhpcy5nZW1TaXplICsgdGhpcy5nZW1TaXplIC8gMixcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnN3YXBTcGVlZCxcbiAgICAgICAgICAgIGNhbGxiYWNrU2NvcGU6IHRoaXMsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoaXMuc3dhcHBpbmdHZW1zIC0tO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc3dhcHBpbmdHZW1zID09IDApe1xuICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5tYXRjaEluQm9hcmQoKSAmJiBzd2FwQmFjayl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN3YXBHZW1zKGdlbTEsIGdlbTIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5tYXRjaEluQm9hcmQoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNYXRjaGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1hdGNoSW5Cb2FyZCgpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzTWF0Y2goaSwgaikpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGhhbmRsZU1hdGNoZXMoKXtcbiAgICAgICAgdGhpcy5yZW1vdmVNYXAgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplOyBpICsrKXtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwW2ldID0gW107XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemU7IGogKyspe1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwW2ldLnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrTWF0Y2hlcygnaG9yaXpvbnRhbCcpO1xuICAgICAgICB0aGlzLm1hcmtNYXRjaGVzKCd2ZXJ0aWNhbCcpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lHZW1zKCk7XG4gICAgfVxuXG4gICAgbWFya01hdGNoZXMoZGlyZWN0aW9uOiBzdHJpbmcpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgbGV0IGNvbG9yU3RyZWFrID0gMTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29sb3IgPSAtMTtcbiAgICAgICAgICAgIGxldCBzdGFydFN0cmVhayA9IDA7XG4gICAgICAgICAgICBsZXQgY29sb3JUb1dhdGNoID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZTsgaiArKyl7XG4gICAgICAgICAgICAgICAgaWYoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVG9XYXRjaCA9IHRoaXMuZ2VtQXQoaSwgaikuZ2VtQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVG9XYXRjaCA9IHRoaXMuZ2VtQXQoaiwgaSkuZ2VtQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGNvbG9yVG9XYXRjaCA9PSBjdXJyZW50Q29sb3Ipe1xuICAgICAgICAgICAgICAgICAgICBjb2xvclN0cmVhayArKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoY29sb3JUb1dhdGNoICE9IGN1cnJlbnRDb2xvciB8fCBqID09IHRoaXMuZmllbGRTaXplIC0gMSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbG9yU3RyZWFrID49IDMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJIT1JJWk9OVEFMIDo6IExlbmd0aCA9IFwiICsgY29sb3JTdHJlYWsgKyBcIiA6OiBTdGFydCA9IChcIiArIGkgKyBcIixcIiArIHN0YXJ0U3RyZWFrICsgXCIpIDo6IENvbG9yID0gXCIgKyBjdXJyZW50Q29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZFUlRJQ0FMIDo6IExlbmd0aCA9IFwiICsgY29sb3JTdHJlYWsgKyBcIiA6OiBTdGFydCA9IChcIiArIHN0YXJ0U3RyZWFrICsgXCIsXCIgKyBpICsgXCIpIDo6IENvbG9yID0gXCIgKyBjdXJyZW50Q29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBrID0gMDsgayA8IGNvbG9yU3RyZWFrOyBrICsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXBbaV1bc3RhcnRTdHJlYWsgKyBrXSArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXBbc3RhcnRTdHJlYWsgKyBrXVtpXSArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRTdHJlYWsgPSBqO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclN0cmVhayA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IGNvbG9yVG9XYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95R2Vtcygpe1xuICAgICAgICBsZXQgZGVzdHJveWVkID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplOyBpICsrKXtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZTsgaiArKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5yZW1vdmVNYXBbaV1bal0gPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVkICsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmRlc3Ryb3lTcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrU2NvcGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llZCAtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbEFycmF5LnB1c2godGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZXN0cm95ZWQgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZUdlbXNGYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGVuaXNoRmllbGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlR2Vtc0ZhbGwoKXtcbiAgICAgICAgZm9yKGxldCBpID0gdGhpcy5maWVsZFNpemUgLSAyOyBpID49IDA7IGkgLS0pe1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmYWxsVGlsZXMgPSB0aGlzLmhvbGVzQmVsb3coaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGlmKGZhbGxUaWxlcyA+IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50d2VlbnMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnkgKyBmYWxsVGlsZXMgKiB0aGlzLmdlbVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZmFsbFNwZWVkICogZmFsbFRpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2kgKyBmYWxsVGlsZXNdW2pdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbVNwcml0ZTogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbUNvbG9yOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob2xlc0JlbG93KHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcil7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSByb3cgKyAxOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgaWYodGhpcy5nYW1lQXJyYXlbaV1bY29sXS5pc0VtcHR5KXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXBsZW5pc2hGaWVsZCgpe1xuICAgICAgICBsZXQgcmVwbGVuaXNoZWQgPSAwO1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemU7IGogKyspe1xuICAgICAgICAgICAgbGV0IGVtcHR5U3BvdHMgPSB0aGlzLmhvbGVzSW5Db2woaik7XG4gICAgICAgICAgICBpZihlbXB0eVNwb3RzID4gMCl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGVtcHR5U3BvdHM7IGkgKyspe1xuICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2hlZCArKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbUNvbG9yID0gdGhpcy5yYW5kb21Db2xvcigpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbUNvbG9yID0gcmFuZG9tQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSA9IHRoaXMucG9vbEFycmF5LnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS5zZXRUZXh0dXJlKHJhbmRvbUNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUueCA9IHRoaXMuZ2VtU2l6ZSAqIGogKyB0aGlzLmdlbVNpemUgLyAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUueSA9IHRoaXMuZ2VtU2l6ZSAvIDIgLSAoZW1wdHlTcG90cyAtIGkpICogdGhpcy5nZW1TaXplO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUuYWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudHdlZW5zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLmdlbVNpemUgKiBpICsgdGhpcy5nZW1TaXplIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmZhbGxTcGVlZCAqIGVtcHR5U3BvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1Njb3BlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2hlZCAtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXBsZW5pc2hlZCA9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5tYXRjaEluQm9hcmQoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnRpbWUuYWRkRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiAyNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMuaGFuZGxlTWF0Y2hlcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5QaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob2xlc0luQ29sKGNvbDogbnVtYmVyKXtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZTsgaSArKyl7XG4gICAgICAgICAgICBpZih0aGlzLmdhbWVBcnJheVtpXVtjb2xdLmlzRW1wdHkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJhbmRvbUNvbG9yKCk6c3RyaW5ne1xuICAgICAgICByZXR1cm4gdGhpcy5nZW1Db2xvcnNbUGhhc2VyLk1hdGguQmV0d2VlbigwLCB0aGlzLmdlbUNvbG9ycy5sZW5ndGggLSAxKV07XG4gICAgfVxufSJdLCJuYW1lcyI6WyJHZW0iLCJNYXRjaCIsImRyYXdGaWVsZCIsImdhbWVBcnJheSIsInBvb2xBcnJheSIsImlucHV0QXJyYXkiLCJnZW1Hcm91cCIsInNjZW5lIiwiYWRkIiwiZ3JvdXAiLCJpIiwiZmllbGRTaXplIiwiaiIsImNvbG9yIiwicmFuZG9tQ29sb3IiLCJ4Iiwic3RhcnRYIiwiZ2VtU2l6ZSIsInkiLCJzdGFydFkiLCJnZW0iLCJzcHJpdGUiLCJnZW1EYXRhIiwiZ2VtQ29sb3IiLCJnZW1TcHJpdGUiLCJpc0VtcHR5IiwiaGl0Qm94IiwicmVjdGFuZ2xlIiwib24iLCJwb2ludGVyIiwiZ2VtU2VsZWN0Iiwic2V0SW50ZXJhY3RpdmUiLCJpc01hdGNoIiwicm93IiwiY29sIiwiaXNIb3Jpem9udGFsTWF0Y2giLCJpc1ZlcnRpY2FsTWF0Y2giLCJnZW1BdCIsImNhblBpY2siLCJkcmFnZ2luZyIsInBpY2tlZEdlbSIsInNlbGVjdGVkR2VtIiwic2V0U2NhbGUiLCJzZXREZXB0aCIsInNlbGVjdGVkUm93Iiwic2VsZWN0ZWRDb2wiLCJhcmVUaGVTYW1lIiwiYXJlTmV4dCIsInN3YXBHZW1zIiwic3RhcnRTd2lwZSIsImRlbHRhWCIsImRvd25YIiwiZGVsdGFZIiwiZG93blkiLCJkZWx0YVJvdyIsImRlbHRhQ29sIiwiTWF0aCIsImFicyIsImdldEdlbVJvdyIsImdldEdlbUNvbCIsInN0b3BTd2lwZSIsImdlbTEiLCJnZW0yIiwiZmxvb3IiLCJzd2FwQmFjayIsInN3YXBwaW5nR2VtcyIsImZyb21Db2xvciIsImZyb21TcHJpdGUiLCJ0b0NvbG9yIiwidG9TcHJpdGUiLCJnZW0xUm93IiwiZ2VtMUNvbCIsImdlbTJSb3ciLCJnZW0yQ29sIiwidHdlZW5HZW0iLCJ0d2VlbnMiLCJ0YXJnZXRzIiwiZHVyYXRpb24iLCJzd2FwU3BlZWQiLCJjYWxsYmFja1Njb3BlIiwib25Db21wbGV0ZSIsIm1hdGNoSW5Cb2FyZCIsImhhbmRsZU1hdGNoZXMiLCJyZW1vdmVNYXAiLCJwdXNoIiwibWFya01hdGNoZXMiLCJkZXN0cm95R2VtcyIsImRpcmVjdGlvbiIsImNvbG9yU3RyZWFrIiwiY3VycmVudENvbG9yIiwic3RhcnRTdHJlYWsiLCJjb2xvclRvV2F0Y2giLCJjb25zb2xlIiwibG9nIiwiayIsImRlc3Ryb3llZCIsImFscGhhIiwiZGVzdHJveVNwZWVkIiwidmlzaWJsZSIsIm1ha2VHZW1zRmFsbCIsInJlcGxlbmlzaEZpZWxkIiwiZmFsbFRpbGVzIiwiaG9sZXNCZWxvdyIsImZhbGxTcGVlZCIsInJlc3VsdCIsInJlcGxlbmlzaGVkIiwiZW1wdHlTcG90cyIsImhvbGVzSW5Db2wiLCJwb3AiLCJzZXRUZXh0dXJlIiwidGltZSIsImFkZEV2ZW50IiwiZGVsYXkiLCJjYWxsYmFjayIsImdlbUNvbG9ycyIsIlBoYXNlciIsIkJldHdlZW4iLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsImlucHV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/game/components/Match.ts\n"));

/***/ })

});