"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_App_tsx",{

/***/ "./src/game/components/Match.ts":
/*!**************************************!*\
  !*** ./src/game/components/Match.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Match; }\n/* harmony export */ });\nclass Gem {\n}\nclass Match {\n    drawField() {\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.gemGroup = this.scene.add.group();\n        for(let i = 0; i < this.fieldSizeY; i++){\n            this.gameArray[i] = [];\n            this.inputArray[i] = [];\n            for(let j = 0; j < this.fieldSizeX; j++){\n                let color = this.randomColor();\n                let x = this.startX + (this.gemSize * j + this.gemSize / 2);\n                let y = this.startY + (this.gemSize * i + this.gemSize / 2);\n                let gem = this.scene.add.sprite(x, y, color);\n                this.gemGroup.add(gem);\n                do {\n                    let randomColor = this.randomColor();\n                    gem.setTexture(randomColor);\n                    this.gameArray[i][j] = {\n                        gemColor: randomColor,\n                        gemSprite: gem,\n                        isEmpty: false\n                    };\n                }while (this.isMatch(i, j));\n            }\n        }\n        this.gemGroup.setVisible(false);\n    }\n    isMatch(row, col) {\n        return this.isHorizontalMatch(row, col) || this.isVerticalMatch(row, col);\n    }\n    isHorizontalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row, col - 1).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row, col - 2).gemColor;\n    }\n    isVerticalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row - 1, col).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row - 2, col).gemColor;\n    }\n    gemAt(row, col) {\n        if (row < 0 || row >= this.fieldSizeY || col < 0 || col >= this.fieldSizeX) {\n            return -1;\n        }\n        return this.gameArray[row][col];\n    }\n    gemSelect(pointer) {\n        if (this.canPick) {\n            this.dragging = true;\n            let row = Math.floor((pointer.y - this.startY) / this.gemSize);\n            let col = Math.floor((pointer.x - this.startX) / this.gemSize);\n            let pickedGem = this.gemAt(row, col);\n            if (pickedGem != -1) {\n                if (this.selectedGem == null) {\n                    pickedGem.gemSprite.setScale(1.2);\n                    pickedGem.gemSprite.setDepth(1);\n                    this.selectedGem = pickedGem;\n                } else {\n                    if (this.areTheSame(pickedGem, this.selectedGem)) {\n                        this.selectedGem.gemSprite.setScale(1);\n                        this.selectedGem = null;\n                    } else {\n                        if (this.areNext(pickedGem, this.selectedGem)) {\n                            this.selectedGem.gemSprite.setScale(1);\n                            this.swapGems(this.selectedGem, pickedGem, true);\n                        } else {\n                            this.selectedGem.gemSprite.setScale(1);\n                            pickedGem.gemSprite.setScale(1.2);\n                            this.selectedGem = pickedGem;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    startSwipe(pointer) {\n        if (this.dragging && this.selectedGem != null) {\n            let deltaX = pointer.downX - pointer.x;\n            let deltaY = pointer.downY - pointer.y;\n            let deltaRow = 0;\n            let deltaCol = 0;\n            if (deltaX > this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = -1;\n            }\n            if (deltaX < -this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = 1;\n            }\n            if (deltaY > this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = -1;\n            }\n            if (deltaY < -this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = 1;\n            }\n            if (deltaRow + deltaCol != 0) {\n                let pickedGem = this.gemAt(this.getGemRow(this.selectedGem) + deltaRow, this.getGemCol(this.selectedGem) + deltaCol);\n                if (pickedGem != -1) {\n                    this.selectedGem.gemSprite.setScale(1);\n                    this.swapGems(this.selectedGem, pickedGem, true);\n                    this.dragging = false;\n                }\n            }\n        }\n    }\n    stopSwipe() {\n        this.dragging = false;\n    }\n    areTheSame(gem1, gem2) {\n        return this.getGemRow(gem1) == this.getGemRow(gem2) && this.getGemCol(gem1) == this.getGemCol(gem2);\n    }\n    getGemRow(gem) {\n        return Math.floor((gem.gemSprite.y - this.startY) / this.gemSize);\n    }\n    getGemCol(gem) {\n        return Math.floor((gem.gemSprite.x - this.startX) / this.gemSize);\n    }\n    areNext(gem1, gem2) {\n        return Math.abs(this.getGemRow(gem1) - this.getGemRow(gem2)) + Math.abs(this.getGemCol(gem1) - this.getGemCol(gem2)) == 1;\n    }\n    swapGems(gem1, gem2, swapBack) {\n        this.swappingGems = 2;\n        this.canPick = false;\n        let fromColor = gem1.gemColor;\n        let fromSprite = gem1.gemSprite;\n        let toColor = gem2.gemColor;\n        let toSprite = gem2.gemSprite;\n        let gem1Row = this.getGemRow(gem1);\n        let gem1Col = this.getGemCol(gem1);\n        let gem2Row = this.getGemRow(gem2);\n        let gem2Col = this.getGemCol(gem2);\n        this.gameArray[gem1Row][gem1Col].gemColor = toColor;\n        this.gameArray[gem1Row][gem1Col].gemSprite = toSprite;\n        this.gameArray[gem2Row][gem2Col].gemColor = fromColor;\n        this.gameArray[gem2Row][gem2Col].gemSprite = fromSprite;\n        this.tweenGem(gem1, gem2, swapBack);\n        this.tweenGem(gem2, gem1, swapBack);\n    }\n    tweenGem(gem1, gem2, swapBack) {\n        let row = this.getGemRow(gem1);\n        let col = this.getGemCol(gem1);\n        this.scene.tweens.add({\n            targets: this.gameArray[row][col].gemSprite,\n            x: this.startX + (col * this.gemSize + this.gemSize / 2),\n            y: this.startY + (row * this.gemSize + this.gemSize / 2),\n            duration: this.swapSpeed,\n            callbackScope: this,\n            onComplete: function() {\n                this.swappingGems--;\n                if (this.swappingGems == 0) {\n                    if (!this.matchInBoard() && swapBack) {\n                        this.swapGems(gem1, gem2, false);\n                    } else {\n                        if (this.matchInBoard()) {\n                            this.handleMatches();\n                        } else {\n                            this.canPick = true;\n                            this.selectedGem = null;\n                        }\n                    }\n                }\n            }\n        });\n    }\n    matchInBoard() {\n        for(let i = 0; i < this.fieldSizeY; i++){\n            for(let j = 0; j < this.fieldSizeX; j++){\n                if (this.isMatch(i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    handleMatches() {\n        this.removeMap = [];\n        for(let i = 0; i < this.fieldSizeY; i++){\n            this.removeMap[i] = [];\n            for(let j = 0; j < this.fieldSizeX; j++){\n                this.removeMap[i].push(0);\n            }\n        }\n        this.markMatches(\"horizontal\");\n        this.markMatches(\"vertical\");\n        this.destroyGems();\n    }\n    markMatches(direction) {\n        let iMax = direction == \"horizontal\" ? this.fieldSizeY : this.fieldSizeX;\n        let jMax = direction == \"horizontal\" ? this.fieldSizeX : this.fieldSizeY;\n        for(let i = 0; i < iMax; i++){\n            let colorStreak = 1;\n            let currentColor = -1;\n            let startStreak = 0;\n            let colorToWatch = 0;\n            for(let j = 0; j < jMax; j++){\n                if (direction == \"horizontal\") {\n                    colorToWatch = this.gemAt(i, j).gemColor;\n                } else {\n                    colorToWatch = this.gemAt(j, i).gemColor;\n                }\n                if (colorToWatch == currentColor) {\n                    colorStreak++;\n                }\n                if (colorToWatch != currentColor || j == jMax - 1) {\n                    if (colorStreak >= 3) {\n                        if (direction == \"horizontal\") {\n                            console.log(\"HORIZONTAL :: Length = \" + colorStreak + \" :: Start = (\" + i + \",\" + startStreak + \") :: Color = \" + currentColor);\n                        } else {\n                            console.log(\"VERTICAL :: Length = \" + colorStreak + \" :: Start = (\" + startStreak + \",\" + i + \") :: Color = \" + currentColor);\n                        }\n                        for(let k = 0; k < colorStreak; k++){\n                            if (direction == \"horizontal\") {\n                                this.removeMap[i][startStreak + k]++;\n                            } else {\n                                this.removeMap[startStreak + k][i]++;\n                            }\n                        }\n                    }\n                    startStreak = j;\n                    colorStreak = 1;\n                    currentColor = colorToWatch;\n                }\n            }\n        }\n    }\n    destroyGems() {\n        let destroyed = 0;\n        for(let i = 0; i < this.fieldSizeY; i++){\n            for(let j = 0; j < this.fieldSizeX; j++){\n                if (this.removeMap[i][j] > 0) {\n                    destroyed++;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        alpha: 0.5,\n                        duration: this.destroySpeed,\n                        callbackScope: this,\n                        onComplete: function() {\n                            destroyed--;\n                            this.gameArray[i][j].gemSprite.visible = false;\n                            this.poolArray.push(this.gameArray[i][j].gemSprite);\n                            this.addScore(1);\n                            if (destroyed == 0) {\n                                this.makeGemsFall();\n                                this.replenishField();\n                            }\n                        }\n                    });\n                    this.gameArray[i][j].isEmpty = true;\n                }\n            }\n        }\n    }\n    makeGemsFall() {\n        for(let i = this.fieldSizeY - 2; i >= 0; i--){\n            for(let j = 0; j < this.fieldSizeX; j++){\n                if (!this.gameArray[i][j].isEmpty) {\n                    let fallTiles = this.holesBelow(i, j);\n                    if (fallTiles > 0) {\n                        this.scene.tweens.add({\n                            targets: this.gameArray[i][j].gemSprite,\n                            y: this.gameArray[i][j].gemSprite.y + fallTiles * this.gemSize,\n                            duration: this.fallSpeed * fallTiles\n                        });\n                        this.gameArray[i + fallTiles][j] = {\n                            gemSprite: this.gameArray[i][j].gemSprite,\n                            gemColor: this.gameArray[i][j].gemColor,\n                            isEmpty: false\n                        };\n                        this.gameArray[i][j].isEmpty = true;\n                    }\n                }\n            }\n        }\n    }\n    holesBelow(row, col) {\n        let result = 0;\n        for(let i = row + 1; i < this.fieldSizeY; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    replenishField() {\n        let replenished = 0;\n        for(let j = 0; j < this.fieldSizeX; j++){\n            let emptySpots = this.holesInCol(j);\n            if (emptySpots > 0) {\n                for(let i = 0; i < emptySpots; i++){\n                    replenished++;\n                    let randomColor = this.randomColor();\n                    this.gameArray[i][j].gemColor = randomColor;\n                    this.gameArray[i][j].gemSprite = this.poolArray.pop();\n                    this.gameArray[i][j].gemSprite.setTexture(randomColor);\n                    this.gameArray[i][j].gemSprite.visible = true;\n                    this.gameArray[i][j].gemSprite.x = this.startX + (this.gemSize * j + this.gemSize / 2);\n                    this.gameArray[i][j].gemSprite.y = this.startY + (this.gemSize / 2 - (emptySpots - i) * this.gemSize);\n                    this.gameArray[i][j].gemSprite.alpha = 0;\n                    this.gameArray[i][j].isEmpty = false;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        y: this.startY + (this.gemSize * i + this.gemSize / 2),\n                        alpha: 1,\n                        duration: this.fallSpeed * emptySpots,\n                        callbackScope: this,\n                        onComplete: function() {\n                            replenished--;\n                            if (replenished == 0) {\n                                if (this.matchInBoard()) {\n                                    this.scene.time.addEvent({\n                                        delay: 250,\n                                        callback: this.handleMatches()\n                                    });\n                                } else {\n                                    this.canPick = true;\n                                    this.selectedGem = null;\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n    holesInCol(col) {\n        var result = 0;\n        for(let i = 0; i < this.fieldSizeY; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    randomColor() {\n        return this.gemColors[Phaser.Math.Between(0, this.gemColors.length - 1)];\n    }\n    addScore(value) {\n        this.score += value;\n        if (this.scoreText) this.scoreText.setText(\"Score: \" + this.score);\n        if (this.callbackScore) this.callbackScore(value);\n    }\n    constructor(scene, x, y){\n        this.startX = 0;\n        this.startY = 0;\n        //\n        this.fieldSize = 6;\n        this.fieldSizeX = 7;\n        this.fieldSizeY = 6;\n        this.gemSize = 128;\n        this.swapSpeed = 200;\n        this.fallSpeed = 100;\n        this.destroySpeed = 200;\n        this.gemColors = [\n            \"blue\",\n            \"green\",\n            \"orange\",\n            \"red\"\n        ];\n        //\n        this.canPick = true;\n        this.dragging = false;\n        //\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        //\n        this.score = 0;\n        this.scene = scene;\n        this.startX = x - this.fieldSizeX * this.gemSize / 2;\n        this.startY = y - this.fieldSizeY * this.gemSize / 2;\n        // Display Score\n        // this.scoreText = this.scene.add.text( GameLib.screenWidth/2, this.startY - 30, \"Score: \" + this.score, {fontSize:40,color:'black'} ).setOrigin(0.5)\n        this.drawField();\n        this.scene.input.on(\"pointerdown\", this.gemSelect, this);\n        this.scene.input.on(\"pointermove\", this.startSwipe, this);\n        this.scene.input.on(\"pointerup\", this.stopSwipe, this);\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUN2QmlCLFlBQXNCO1lBQUM7WUFBTztZQUFRO1lBQVM7U0FBTTtRQUNyRCxFQUFFO2FBQ0Y1RSxVQUFtQjthQUNuQkMsV0FBb0I7UUFDcEIsRUFBRTthQUNGbEMsWUFBaUIsRUFBRTthQUNuQkMsWUFBaUIsRUFBRTthQUNuQkMsYUFBa0IsRUFBRTtRQU1wQixFQUFFO2FBQ0ZnSCxRQUFnQjtRQU1aLElBQUksQ0FBQzlHLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNVLE1BQU0sR0FBR0QsSUFBSyxJQUFJLENBQUNILFVBQVUsR0FBQyxJQUFJLENBQUNLLE9BQU8sR0FBRTtRQUNqRCxJQUFJLENBQUNFLE1BQU0sR0FBR0QsSUFBSyxJQUFJLENBQUNSLFVBQVUsR0FBQyxJQUFJLENBQUNPLE9BQU8sR0FBRTtRQUVqRCxnQkFBZ0I7UUFDaEIsc0pBQXNKO1FBRXRKLElBQUksQ0FBQ2hCLFNBQVM7UUFDZCxJQUFJLENBQUNLLEtBQUssQ0FBQ29ILEtBQUssQ0FBQ0MsRUFBRSxDQUFDLGVBQWUsSUFBSSxDQUFDMUYsU0FBUyxFQUFFLElBQUk7UUFDdkQsSUFBSSxDQUFDM0IsS0FBSyxDQUFDb0gsS0FBSyxDQUFDQyxFQUFFLENBQUMsZUFBZSxJQUFJLENBQUM3RSxVQUFVLEVBQUUsSUFBSTtRQUN4RCxJQUFJLENBQUN4QyxLQUFLLENBQUNvSCxLQUFLLENBQUNDLEVBQUUsQ0FBQyxhQUFhLElBQUksQ0FBQ25FLFNBQVMsRUFBRSxJQUFJO0lBQ3pEO0FBMFhKO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2dhbWUvY29tcG9uZW50cy9NYXRjaC50cz84NmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHYW1lTGliIGZyb20gXCJAL2xpYi9HYW1lTGliXCI7XG5pbXBvcnQgeyBHYW1lLCBHYW1lT2JqZWN0cywgU2NlbmUgfSBmcm9tIFwicGhhc2VyXCI7XG5cbmNsYXNzIEdlbXtcbiAgICBnZW1Db2xvcjogc3RyaW5nXG4gICAgZ2VtU3ByaXRlOiBHYW1lT2JqZWN0cy5TcHJpdGVcbiAgICBpc0VtcHR5OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGNoe1xuXG4gICAgc2NlbmU6IFBoYXNlci5TY2VuZVxuICAgIHN0YXJ0WDogbnVtYmVyID0gMFxuICAgIHN0YXJ0WTogbnVtYmVyID0gMFxuICAgIC8vXG4gICAgZmllbGRTaXplOiBudW1iZXIgPSA2XG4gICAgZmllbGRTaXplWDogbnVtYmVyID0gN1xuICAgIGZpZWxkU2l6ZVk6IG51bWJlciA9IDZcbiAgICBnZW1TaXplOiBudW1iZXIgPSAxMjhcbiAgICBzd2FwU3BlZWQ6IG51bWJlciA9IDIwMFxuICAgIGZhbGxTcGVlZDogbnVtYmVyID0gMTAwXG4gICAgZGVzdHJveVNwZWVkOiBudW1iZXIgPSAyMDBcbiAgICBnZW1Db2xvcnM6IHN0cmluZ1tdID0gWydibHVlJywnZ3JlZW4nLCdvcmFuZ2UnLCdyZWQnXVxuICAgIC8vXG4gICAgY2FuUGljazogYm9vbGVhbiA9IHRydWVcbiAgICBkcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG4gICAgLy9cbiAgICBnYW1lQXJyYXk6IGFueSA9IFtdXG4gICAgcG9vbEFycmF5OiBhbnkgPSBbXVxuICAgIGlucHV0QXJyYXk6IGFueSA9IFtdXG4gICAgZ2VtR3JvdXA6IEdhbWVPYmplY3RzLkdyb3VwXG4gICAgLy9cbiAgICBzZWxlY3RlZEdlbTogR2VtIHwgbnVsbFxuICAgIHN3YXBwaW5nR2VtczogbnVtYmVyXG4gICAgcmVtb3ZlTWFwOiBhbnlcbiAgICAvL1xuICAgIHNjb3JlOiBudW1iZXIgPSAwXG4gICAgc2NvcmVUZXh0OiBHYW1lT2JqZWN0cy5UZXh0XG4gICAgLy9cbiAgICBjYWxsYmFja1Njb3JlOiBGdW5jdGlvbiB8IG51bGxcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgeDogbnVtYmVyLCB5OiBudW1iZXIpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmVcbiAgICAgICAgdGhpcy5zdGFydFggPSB4IC0gKHRoaXMuZmllbGRTaXplWCp0aGlzLmdlbVNpemUgLzIpIFxuICAgICAgICB0aGlzLnN0YXJ0WSA9IHkgLSAodGhpcy5maWVsZFNpemVZKnRoaXMuZ2VtU2l6ZSAvMikgXG5cbiAgICAgICAgLy8gRGlzcGxheSBTY29yZVxuICAgICAgICAvLyB0aGlzLnNjb3JlVGV4dCA9IHRoaXMuc2NlbmUuYWRkLnRleHQoIEdhbWVMaWIuc2NyZWVuV2lkdGgvMiwgdGhpcy5zdGFydFkgLSAzMCwgXCJTY29yZTogXCIgKyB0aGlzLnNjb3JlLCB7Zm9udFNpemU6NDAsY29sb3I6J2JsYWNrJ30gKS5zZXRPcmlnaW4oMC41KVxuXG4gICAgICAgIHRoaXMuZHJhd0ZpZWxkKCk7XG4gICAgICAgIHRoaXMuc2NlbmUuaW5wdXQub24oXCJwb2ludGVyZG93blwiLCB0aGlzLmdlbVNlbGVjdCwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NlbmUuaW5wdXQub24oXCJwb2ludGVybW92ZVwiLCB0aGlzLnN0YXJ0U3dpcGUsIHRoaXMpO1xuICAgICAgICB0aGlzLnNjZW5lLmlucHV0Lm9uKFwicG9pbnRlcnVwXCIsIHRoaXMuc3RvcFN3aXBlLCB0aGlzKTtcbiAgICB9XG5cbiAgICBkcmF3RmllbGQoKXtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5wb29sQXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dEFycmF5ID0gW107XG4gICAgICAgIHRoaXMuZ2VtR3JvdXAgPSB0aGlzLnNjZW5lLmFkZC5ncm91cCgpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemVZOyBpICsrKXtcbiAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldID0gW107XG4gICAgICAgICAgICB0aGlzLmlucHV0QXJyYXlbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZVg7IGogKyspe1xuICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IHRoaXMucmFuZG9tQ29sb3IoKVxuXG4gICAgICAgICAgICAgICAgbGV0IHggPSB0aGlzLnN0YXJ0WCArICh0aGlzLmdlbVNpemUgKiBqICsgdGhpcy5nZW1TaXplIC8gMilcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHRoaXMuc3RhcnRZICsgKHRoaXMuZ2VtU2l6ZSAqIGkgKyB0aGlzLmdlbVNpemUgLyAyKVxuICAgICAgICAgICAgICAgIGxldCBnZW0gPSB0aGlzLnNjZW5lLmFkZC5zcHJpdGUoIHggLCB5LCBjb2xvcik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdlbUdyb3VwLmFkZChnZW0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRve1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tQ29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbS5zZXRUZXh0dXJlKHJhbmRvbUNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW1Db2xvcjogcmFuZG9tQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW1TcHJpdGU6IGdlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW1wdHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlKHRoaXMuaXNNYXRjaChpLCBqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlbUdyb3VwLnNldFZpc2libGUoZmFsc2UpO1xuICAgIH1cblxuICAgIGlzTWF0Y2gocm93Om51bWJlciwgY29sOm51bWJlcik6IGJvb2xlYW57XG4gICAgICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbE1hdGNoKHJvdywgY29sKSB8fCB0aGlzLmlzVmVydGljYWxNYXRjaChyb3csIGNvbCk7XG4gICAgfVxuXG4gICAgaXNIb3Jpem9udGFsTWF0Y2gocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93LCBjb2wgLSAxKS5nZW1Db2xvciAmJiB0aGlzLmdlbUF0KHJvdywgY29sKS5nZW1Db2xvciA9PSB0aGlzLmdlbUF0KHJvdywgY29sIC0gMikuZ2VtQ29sb3I7XG4gICAgfVxuXG4gICAgaXNWZXJ0aWNhbE1hdGNoKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IGJvb2xlYW57XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW1BdChyb3csIGNvbCkuZ2VtQ29sb3IgPT0gdGhpcy5nZW1BdChyb3cgLSAxLCBjb2wpLmdlbUNvbG9yICYmIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93IC0gMiwgY29sKS5nZW1Db2xvcjtcbiAgICB9XG4gICAgXG4gICAgZ2VtQXQocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYW55e1xuICAgICAgICBpZihyb3cgPCAwIHx8IHJvdyA+PSB0aGlzLmZpZWxkU2l6ZVkgfHwgY29sIDwgMCB8fCBjb2wgPj0gdGhpcy5maWVsZFNpemVYKXtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nYW1lQXJyYXlbcm93XVtjb2xdO1xuICAgIH1cblxuICAgIGdlbVNlbGVjdChwb2ludGVyOiBQaGFzZXIuSW5wdXQuUG9pbnRlcil7XG4gICAgICAgIGlmKHRoaXMuY2FuUGljayl7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKCAocG9pbnRlci55IC0gdGhpcy5zdGFydFkpIC8gdGhpcy5nZW1TaXplKTtcbiAgICAgICAgICAgIGxldCBjb2wgPSBNYXRoLmZsb29yKCAocG9pbnRlci54IC0gdGhpcy5zdGFydFgpIC8gdGhpcy5nZW1TaXplKTtcbiAgICAgICAgICAgIGxldCBwaWNrZWRHZW0gPSB0aGlzLmdlbUF0KHJvdywgY29sKVxuICAgICAgICAgICAgaWYocGlja2VkR2VtICE9IC0xKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNlbGVjdGVkR2VtID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBwaWNrZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEuMik7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0RGVwdGgoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBwaWNrZWRHZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJlVGhlU2FtZShwaWNrZWRHZW0sIHRoaXMuc2VsZWN0ZWRHZW0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJlTmV4dChwaWNrZWRHZW0sIHRoaXMuc2VsZWN0ZWRHZW0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN3YXBHZW1zKHRoaXMuc2VsZWN0ZWRHZW0sIHBpY2tlZEdlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMS4yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gcGlja2VkR2VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRTd2lwZShwb2ludGVyOiBQaGFzZXIuSW5wdXQuUG9pbnRlcil7XG4gICAgICAgIGlmKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5zZWxlY3RlZEdlbSAhPSBudWxsKXtcbiAgICAgICAgICAgIGxldCBkZWx0YVggPSBwb2ludGVyLmRvd25YIC0gcG9pbnRlci54O1xuICAgICAgICAgICAgbGV0IGRlbHRhWSA9IHBvaW50ZXIuZG93blkgLSBwb2ludGVyLnk7XG4gICAgICAgICAgICBsZXQgZGVsdGFSb3cgPSAwO1xuICAgICAgICAgICAgbGV0IGRlbHRhQ29sID0gMDtcbiAgICAgICAgICAgIGlmKGRlbHRhWCA+IHRoaXMuZ2VtU2l6ZSAvIDIgJiYgTWF0aC5hYnMoZGVsdGFZKSA8IHRoaXMuZ2VtU2l6ZSAvIDQpe1xuICAgICAgICAgICAgICAgIGRlbHRhQ29sID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWx0YVggPCAtdGhpcy5nZW1TaXplIC8gMiAmJiBNYXRoLmFicyhkZWx0YVkpIDwgdGhpcy5nZW1TaXplIC8gNCl7XG4gICAgICAgICAgICAgICAgZGVsdGFDb2wgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVsdGFZID4gdGhpcy5nZW1TaXplIC8gMiAmJiBNYXRoLmFicyhkZWx0YVgpIDwgdGhpcy5nZW1TaXplIC8gNCl7XG4gICAgICAgICAgICAgICAgZGVsdGFSb3cgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRlbHRhWSA8IC10aGlzLmdlbVNpemUgLyAyICYmIE1hdGguYWJzKGRlbHRhWCkgPCB0aGlzLmdlbVNpemUgLyA0KXtcbiAgICAgICAgICAgICAgICBkZWx0YVJvdyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWx0YVJvdyArIGRlbHRhQ29sICE9IDApe1xuICAgICAgICAgICAgICAgIGxldCBwaWNrZWRHZW0gPSB0aGlzLmdlbUF0KHRoaXMuZ2V0R2VtUm93KHRoaXMuc2VsZWN0ZWRHZW0pICsgZGVsdGFSb3csIHRoaXMuZ2V0R2VtQ29sKHRoaXMuc2VsZWN0ZWRHZW0pICsgZGVsdGFDb2wpO1xuICAgICAgICAgICAgICAgIGlmKHBpY2tlZEdlbSAhPSAtMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN3YXBHZW1zKHRoaXMuc2VsZWN0ZWRHZW0sIHBpY2tlZEdlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wU3dpcGUoKXtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFyZVRoZVNhbWUoZ2VtMTogR2VtLCBnZW0yOiBHZW0pe1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW1Sb3coZ2VtMSkgPT0gdGhpcy5nZXRHZW1Sb3coZ2VtMikgJiYgdGhpcy5nZXRHZW1Db2woZ2VtMSkgPT0gdGhpcy5nZXRHZW1Db2woZ2VtMik7XG4gICAgfVxuXG4gICAgZ2V0R2VtUm93KGdlbTogR2VtKXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoIChnZW0uZ2VtU3ByaXRlLnkgLSB0aGlzLnN0YXJ0WSkgLyB0aGlzLmdlbVNpemUpO1xuICAgIH1cblxuICAgIGdldEdlbUNvbChnZW06IEdlbSl7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCAoZ2VtLmdlbVNwcml0ZS54IC0gdGhpcy5zdGFydFgpIC8gdGhpcy5nZW1TaXplKTtcbiAgICB9XG5cbiAgICBhcmVOZXh0KGdlbTE6IEdlbSwgZ2VtMjogR2VtKXtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0R2VtUm93KGdlbTEpIC0gdGhpcy5nZXRHZW1Sb3coZ2VtMikpICsgTWF0aC5hYnModGhpcy5nZXRHZW1Db2woZ2VtMSkgLSB0aGlzLmdldEdlbUNvbChnZW0yKSkgPT0gMTtcbiAgICB9XG5cbiAgICBzd2FwR2VtcyhnZW0xOiBHZW0sIGdlbTI6IEdlbSwgc3dhcEJhY2s6IGJvb2xlYW4pe1xuICAgICAgICB0aGlzLnN3YXBwaW5nR2VtcyA9IDI7XG4gICAgICAgIHRoaXMuY2FuUGljayA9IGZhbHNlO1xuICAgICAgICBsZXQgZnJvbUNvbG9yID0gZ2VtMS5nZW1Db2xvcjtcbiAgICAgICAgbGV0IGZyb21TcHJpdGUgPSBnZW0xLmdlbVNwcml0ZTtcbiAgICAgICAgbGV0IHRvQ29sb3IgPSBnZW0yLmdlbUNvbG9yO1xuICAgICAgICBsZXQgdG9TcHJpdGUgPSBnZW0yLmdlbVNwcml0ZTtcbiAgICAgICAgbGV0IGdlbTFSb3cgPSB0aGlzLmdldEdlbVJvdyhnZW0xKTtcbiAgICAgICAgbGV0IGdlbTFDb2wgPSB0aGlzLmdldEdlbUNvbChnZW0xKTtcbiAgICAgICAgbGV0IGdlbTJSb3cgPSB0aGlzLmdldEdlbVJvdyhnZW0yKTtcbiAgICAgICAgbGV0IGdlbTJDb2wgPSB0aGlzLmdldEdlbUNvbChnZW0yKTtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXlbZ2VtMVJvd11bZ2VtMUNvbF0uZ2VtQ29sb3IgPSB0b0NvbG9yO1xuICAgICAgICB0aGlzLmdhbWVBcnJheVtnZW0xUm93XVtnZW0xQ29sXS5nZW1TcHJpdGUgPSB0b1Nwcml0ZTtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXlbZ2VtMlJvd11bZ2VtMkNvbF0uZ2VtQ29sb3IgPSBmcm9tQ29sb3I7XG4gICAgICAgIHRoaXMuZ2FtZUFycmF5W2dlbTJSb3ddW2dlbTJDb2xdLmdlbVNwcml0ZSA9IGZyb21TcHJpdGU7XG4gICAgICAgIHRoaXMudHdlZW5HZW0oZ2VtMSwgZ2VtMiwgc3dhcEJhY2spO1xuICAgICAgICB0aGlzLnR3ZWVuR2VtKGdlbTIsIGdlbTEsIHN3YXBCYWNrKTtcbiAgICB9XG5cbiAgICB0d2VlbkdlbShnZW0xOiBHZW0sIGdlbTI6IEdlbSwgc3dhcEJhY2s6IGJvb2xlYW4pe1xuICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRHZW1Sb3coZ2VtMSk7XG4gICAgICAgIGxldCBjb2wgPSB0aGlzLmdldEdlbUNvbChnZW0xKTtcbiAgICAgICAgdGhpcy5zY2VuZS50d2VlbnMuYWRkKHtcbiAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZ2FtZUFycmF5W3Jvd11bY29sXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICB4OiB0aGlzLnN0YXJ0WCArIChjb2wgKiB0aGlzLmdlbVNpemUgKyB0aGlzLmdlbVNpemUgLyAyKSxcbiAgICAgICAgICAgIHk6IHRoaXMuc3RhcnRZICsgKHJvdyAqIHRoaXMuZ2VtU2l6ZSArIHRoaXMuZ2VtU2l6ZSAvIDIpLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuc3dhcFNwZWVkLFxuICAgICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwcGluZ0dlbXMgLS07XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zd2FwcGluZ0dlbXMgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLm1hdGNoSW5Cb2FyZCgpICYmIHN3YXBCYWNrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcEdlbXMoZ2VtMSwgZ2VtMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLm1hdGNoSW5Cb2FyZCgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1hdGNoZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5QaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF0Y2hJbkJvYXJkKCl7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZVk7IGkgKyspe1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplWDsgaiArKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc01hdGNoKGksIGopKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBoYW5kbGVNYXRjaGVzKCl7XG4gICAgICAgIHRoaXMucmVtb3ZlTWFwID0gW107XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZVk7IGkgKyspe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXBbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZVg7IGogKyspe1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwW2ldLnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrTWF0Y2hlcygnaG9yaXpvbnRhbCcpO1xuICAgICAgICB0aGlzLm1hcmtNYXRjaGVzKCd2ZXJ0aWNhbCcpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lHZW1zKCk7XG4gICAgfVxuXG4gICAgbWFya01hdGNoZXMoZGlyZWN0aW9uOiBzdHJpbmcpe1xuICAgICAgICBsZXQgaU1heCA9IGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCc/IHRoaXMuZmllbGRTaXplWTp0aGlzLmZpZWxkU2l6ZVhcbiAgICAgICAgbGV0IGpNYXggPSBkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnPyB0aGlzLmZpZWxkU2l6ZVg6dGhpcy5maWVsZFNpemVZXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBpTWF4OyBpICsrKXtcbiAgICAgICAgICAgIGxldCBjb2xvclN0cmVhayA9IDE7XG4gICAgICAgICAgICBsZXQgY3VycmVudENvbG9yID0gLTE7XG4gICAgICAgICAgICBsZXQgc3RhcnRTdHJlYWsgPSAwO1xuICAgICAgICAgICAgbGV0IGNvbG9yVG9XYXRjaCA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgak1heDsgaiArKyl7XG4gICAgICAgICAgICAgICAgaWYoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVG9XYXRjaCA9IHRoaXMuZ2VtQXQoaSwgaikuZ2VtQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVG9XYXRjaCA9IHRoaXMuZ2VtQXQoaiwgaSkuZ2VtQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGNvbG9yVG9XYXRjaCA9PSBjdXJyZW50Q29sb3Ipe1xuICAgICAgICAgICAgICAgICAgICBjb2xvclN0cmVhayArKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoY29sb3JUb1dhdGNoICE9IGN1cnJlbnRDb2xvciB8fCBqID09IGpNYXggLSAxKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoY29sb3JTdHJlYWsgPj0gMyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkhPUklaT05UQUwgOjogTGVuZ3RoID0gXCIgKyBjb2xvclN0cmVhayArIFwiIDo6IFN0YXJ0ID0gKFwiICsgaSArIFwiLFwiICsgc3RhcnRTdHJlYWsgKyBcIikgOjogQ29sb3IgPSBcIiArIGN1cnJlbnRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVkVSVElDQUwgOjogTGVuZ3RoID0gXCIgKyBjb2xvclN0cmVhayArIFwiIDo6IFN0YXJ0ID0gKFwiICsgc3RhcnRTdHJlYWsgKyBcIixcIiArIGkgKyBcIikgOjogQ29sb3IgPSBcIiArIGN1cnJlbnRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGsgPSAwOyBrIDwgY29sb3JTdHJlYWs7IGsgKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1hcFtpXVtzdGFydFN0cmVhayArIGtdICsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1hcFtzdGFydFN0cmVhayArIGtdW2ldICsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydFN0cmVhayA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RyZWFrID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gY29sb3JUb1dhdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3lHZW1zKCl7XG4gICAgICAgIGxldCBkZXN0cm95ZWQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemVZOyBpICsrKXtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZVg7IGogKyspe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMucmVtb3ZlTWFwW2ldW2pdID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llZCArKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50d2VlbnMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kZXN0cm95U3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1Njb3BlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZWQgLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2xBcnJheS5wdXNoKHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY29yZSgxKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVzdHJveWVkID09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VHZW1zRmFsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxlbmlzaEZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFrZUdlbXNGYWxsKCl7XG4gICAgICAgIGZvcihsZXQgaSA9IHRoaXMuZmllbGRTaXplWSAtIDI7IGkgPj0gMDsgaSAtLSl7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemVYOyBqICsrKXtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmYWxsVGlsZXMgPSB0aGlzLmhvbGVzQmVsb3coaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGlmKGZhbGxUaWxlcyA+IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50d2VlbnMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnkgKyBmYWxsVGlsZXMgKiB0aGlzLmdlbVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZmFsbFNwZWVkICogZmFsbFRpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2kgKyBmYWxsVGlsZXNdW2pdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbVNwcml0ZTogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbUNvbG9yOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob2xlc0JlbG93KHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcil7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSByb3cgKyAxOyBpIDwgdGhpcy5maWVsZFNpemVZOyBpICsrKXtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2FtZUFycmF5W2ldW2NvbF0uaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVwbGVuaXNoRmllbGQoKXtcbiAgICAgICAgbGV0IHJlcGxlbmlzaGVkID0gMDtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplWDsgaiArKyl7XG4gICAgICAgICAgICBsZXQgZW1wdHlTcG90cyA9IHRoaXMuaG9sZXNJbkNvbChqKTtcbiAgICAgICAgICAgIGlmKGVtcHR5U3BvdHMgPiAwKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZW1wdHlTcG90czsgaSArKyl7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaGVkICsrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tQ29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtQ29sb3IgPSByYW5kb21Db2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlID0gdGhpcy5wb29sQXJyYXkucG9wKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnNldFRleHR1cmUocmFuZG9tQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS54ID0gdGhpcy5zdGFydFggKyAodGhpcy5nZW1TaXplICogaiArIHRoaXMuZ2VtU2l6ZSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUueSA9IHRoaXMuc3RhcnRZICsgKHRoaXMuZ2VtU2l6ZSAvIDIgLSAoZW1wdHlTcG90cyAtIGkpICogdGhpcy5nZW1TaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLmFscGhhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5zdGFydFkgKyAodGhpcy5nZW1TaXplICogaSArIHRoaXMuZ2VtU2l6ZSAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5mYWxsU3BlZWQgKiBlbXB0eVNwb3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoZWQgLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVwbGVuaXNoZWQgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubWF0Y2hJbkJvYXJkKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50aW1lLmFkZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogMjUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLmhhbmRsZU1hdGNoZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9sZXNJbkNvbChjb2w6IG51bWJlcil7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemVZOyBpICsrKXtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2FtZUFycmF5W2ldW2NvbF0uaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmFuZG9tQ29sb3IoKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbUNvbG9yc1tQaGFzZXIuTWF0aC5CZXR3ZWVuKDAsIHRoaXMuZ2VtQ29sb3JzLmxlbmd0aCAtIDEpXTtcbiAgICB9XG5cbiAgICBhZGRTY29yZSh2YWx1ZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnNjb3JlICs9IHZhbHVlXG5cbiAgICAgICAgaWYoIHRoaXMuc2NvcmVUZXh0KVxuICAgICAgICAgICAgdGhpcy5zY29yZVRleHQuc2V0VGV4dChcIlNjb3JlOiBcIiArIHRoaXMuc2NvcmUgKVxuXG4gICAgICAgIGlmKCB0aGlzLmNhbGxiYWNrU2NvcmUgKSBcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tTY29yZSh2YWx1ZSlcbiAgICB9XG59Il0sIm5hbWVzIjpbIkdlbSIsIk1hdGNoIiwiZHJhd0ZpZWxkIiwiZ2FtZUFycmF5IiwicG9vbEFycmF5IiwiaW5wdXRBcnJheSIsImdlbUdyb3VwIiwic2NlbmUiLCJhZGQiLCJncm91cCIsImkiLCJmaWVsZFNpemVZIiwiaiIsImZpZWxkU2l6ZVgiLCJjb2xvciIsInJhbmRvbUNvbG9yIiwieCIsInN0YXJ0WCIsImdlbVNpemUiLCJ5Iiwic3RhcnRZIiwiZ2VtIiwic3ByaXRlIiwic2V0VGV4dHVyZSIsImdlbUNvbG9yIiwiZ2VtU3ByaXRlIiwiaXNFbXB0eSIsImlzTWF0Y2giLCJzZXRWaXNpYmxlIiwicm93IiwiY29sIiwiaXNIb3Jpem9udGFsTWF0Y2giLCJpc1ZlcnRpY2FsTWF0Y2giLCJnZW1BdCIsImdlbVNlbGVjdCIsInBvaW50ZXIiLCJjYW5QaWNrIiwiZHJhZ2dpbmciLCJNYXRoIiwiZmxvb3IiLCJwaWNrZWRHZW0iLCJzZWxlY3RlZEdlbSIsInNldFNjYWxlIiwic2V0RGVwdGgiLCJhcmVUaGVTYW1lIiwiYXJlTmV4dCIsInN3YXBHZW1zIiwic3RhcnRTd2lwZSIsImRlbHRhWCIsImRvd25YIiwiZGVsdGFZIiwiZG93blkiLCJkZWx0YVJvdyIsImRlbHRhQ29sIiwiYWJzIiwiZ2V0R2VtUm93IiwiZ2V0R2VtQ29sIiwic3RvcFN3aXBlIiwiZ2VtMSIsImdlbTIiLCJzd2FwQmFjayIsInN3YXBwaW5nR2VtcyIsImZyb21Db2xvciIsImZyb21TcHJpdGUiLCJ0b0NvbG9yIiwidG9TcHJpdGUiLCJnZW0xUm93IiwiZ2VtMUNvbCIsImdlbTJSb3ciLCJnZW0yQ29sIiwidHdlZW5HZW0iLCJ0d2VlbnMiLCJ0YXJnZXRzIiwiZHVyYXRpb24iLCJzd2FwU3BlZWQiLCJjYWxsYmFja1Njb3BlIiwib25Db21wbGV0ZSIsIm1hdGNoSW5Cb2FyZCIsImhhbmRsZU1hdGNoZXMiLCJyZW1vdmVNYXAiLCJwdXNoIiwibWFya01hdGNoZXMiLCJkZXN0cm95R2VtcyIsImRpcmVjdGlvbiIsImlNYXgiLCJqTWF4IiwiY29sb3JTdHJlYWsiLCJjdXJyZW50Q29sb3IiLCJzdGFydFN0cmVhayIsImNvbG9yVG9XYXRjaCIsImNvbnNvbGUiLCJsb2ciLCJrIiwiZGVzdHJveWVkIiwiYWxwaGEiLCJkZXN0cm95U3BlZWQiLCJ2aXNpYmxlIiwiYWRkU2NvcmUiLCJtYWtlR2Vtc0ZhbGwiLCJyZXBsZW5pc2hGaWVsZCIsImZhbGxUaWxlcyIsImhvbGVzQmVsb3ciLCJmYWxsU3BlZWQiLCJyZXN1bHQiLCJyZXBsZW5pc2hlZCIsImVtcHR5U3BvdHMiLCJob2xlc0luQ29sIiwicG9wIiwidGltZSIsImFkZEV2ZW50IiwiZGVsYXkiLCJjYWxsYmFjayIsImdlbUNvbG9ycyIsIlBoYXNlciIsIkJldHdlZW4iLCJsZW5ndGgiLCJ2YWx1ZSIsInNjb3JlIiwic2NvcmVUZXh0Iiwic2V0VGV4dCIsImNhbGxiYWNrU2NvcmUiLCJjb25zdHJ1Y3RvciIsImZpZWxkU2l6ZSIsImlucHV0Iiwib24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/game/components/Match.ts\n"));

/***/ })

});