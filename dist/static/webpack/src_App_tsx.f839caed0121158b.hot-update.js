"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_App_tsx",{

/***/ "./src/game/components/Match.ts":
/*!**************************************!*\
  !*** ./src/game/components/Match.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Match; }\n/* harmony export */ });\n/* harmony import */ var _lib_GameLib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/GameLib */ \"./src/lib/GameLib.ts\");\n\nclass Gem {\n}\nclass Match {\n    drawField() {\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.gemGroup = this.scene.add.group();\n        for(let i = 0; i < this.fieldSizeY; i++){\n            this.gameArray[i] = [];\n            this.inputArray[i] = [];\n            for(let j = 0; j < this.fieldSizeX; j++){\n                let color = this.randomColor();\n                let x = this.startX + (this.gemSize * j + this.gemSize / 2);\n                let y = this.startY + (this.gemSize * i + this.gemSize / 2);\n                let gem = this.scene.add.sprite(x, y, color);\n                this.gemGroup.add(gem);\n                do {\n                    let randomColor = this.randomColor();\n                    gem.setTexture(randomColor);\n                    this.gameArray[i][j] = {\n                        gemColor: randomColor,\n                        gemSprite: gem,\n                        isEmpty: false\n                    };\n                }while (this.isMatch(i, j));\n            }\n        }\n    }\n    isMatch(row, col) {\n        return this.isHorizontalMatch(row, col) || this.isVerticalMatch(row, col);\n    }\n    isHorizontalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row, col - 1).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row, col - 2).gemColor;\n    }\n    isVerticalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row - 1, col).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row - 2, col).gemColor;\n    }\n    gemAt(row, col) {\n        if (row < 0 || row >= this.fieldSizeY || col < 0 || col >= this.fieldSizeX) {\n            return -1;\n        }\n        return this.gameArray[row][col];\n    }\n    gemSelect(pointer) {\n        if (this.canPick) {\n            this.dragging = true;\n            let row = Math.floor((pointer.y - this.startY) / this.gemSize);\n            let col = Math.floor((pointer.x - this.startX) / this.gemSize);\n            let pickedGem = this.gemAt(row, col);\n            if (pickedGem != -1) {\n                if (this.selectedGem == null) {\n                    pickedGem.gemSprite.setScale(1.2);\n                    pickedGem.gemSprite.setDepth(1);\n                    this.selectedGem = pickedGem;\n                } else {\n                    if (this.areTheSame(pickedGem, this.selectedGem)) {\n                        this.selectedGem.gemSprite.setScale(1);\n                        this.selectedGem = null;\n                    } else {\n                        if (this.areNext(pickedGem, this.selectedGem)) {\n                            this.selectedGem.gemSprite.setScale(1);\n                            this.swapGems(this.selectedGem, pickedGem, true);\n                        } else {\n                            this.selectedGem.gemSprite.setScale(1);\n                            pickedGem.gemSprite.setScale(1.2);\n                            this.selectedGem = pickedGem;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    startSwipe(pointer) {\n        if (this.dragging && this.selectedGem != null) {\n            let deltaX = pointer.downX - pointer.x;\n            let deltaY = pointer.downY - pointer.y;\n            let deltaRow = 0;\n            let deltaCol = 0;\n            if (deltaX > this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = -1;\n            }\n            if (deltaX < -this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = 1;\n            }\n            if (deltaY > this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = -1;\n            }\n            if (deltaY < -this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = 1;\n            }\n            if (deltaRow + deltaCol != 0) {\n                let pickedGem = this.gemAt(this.getGemRow(this.selectedGem) + deltaRow, this.getGemCol(this.selectedGem) + deltaCol);\n                if (pickedGem != -1) {\n                    this.selectedGem.gemSprite.setScale(1);\n                    this.swapGems(this.selectedGem, pickedGem, true);\n                    this.dragging = false;\n                }\n            }\n        }\n    }\n    stopSwipe() {\n        this.dragging = false;\n    }\n    areTheSame(gem1, gem2) {\n        return this.getGemRow(gem1) == this.getGemRow(gem2) && this.getGemCol(gem1) == this.getGemCol(gem2);\n    }\n    getGemRow(gem) {\n        return Math.floor((gem.gemSprite.y - this.startY) / this.gemSize);\n    }\n    getGemCol(gem) {\n        return Math.floor((gem.gemSprite.x - this.startX) / this.gemSize);\n    }\n    areNext(gem1, gem2) {\n        return Math.abs(this.getGemRow(gem1) - this.getGemRow(gem2)) + Math.abs(this.getGemCol(gem1) - this.getGemCol(gem2)) == 1;\n    }\n    swapGems(gem1, gem2, swapBack) {\n        this.swappingGems = 2;\n        this.canPick = false;\n        let fromColor = gem1.gemColor;\n        let fromSprite = gem1.gemSprite;\n        let toColor = gem2.gemColor;\n        let toSprite = gem2.gemSprite;\n        let gem1Row = this.getGemRow(gem1);\n        let gem1Col = this.getGemCol(gem1);\n        let gem2Row = this.getGemRow(gem2);\n        let gem2Col = this.getGemCol(gem2);\n        this.gameArray[gem1Row][gem1Col].gemColor = toColor;\n        this.gameArray[gem1Row][gem1Col].gemSprite = toSprite;\n        this.gameArray[gem2Row][gem2Col].gemColor = fromColor;\n        this.gameArray[gem2Row][gem2Col].gemSprite = fromSprite;\n        this.tweenGem(gem1, gem2, swapBack);\n        this.tweenGem(gem2, gem1, swapBack);\n    }\n    tweenGem(gem1, gem2, swapBack) {\n        let row = this.getGemRow(gem1);\n        let col = this.getGemCol(gem1);\n        this.scene.tweens.add({\n            targets: this.gameArray[row][col].gemSprite,\n            x: this.startX + (col * this.gemSize + this.gemSize / 2),\n            y: this.startY + (row * this.gemSize + this.gemSize / 2),\n            duration: this.swapSpeed,\n            callbackScope: this,\n            onComplete: function() {\n                this.swappingGems--;\n                if (this.swappingGems == 0) {\n                    if (!this.matchInBoard() && swapBack) {\n                        this.swapGems(gem1, gem2, false);\n                    } else {\n                        if (this.matchInBoard()) {\n                            this.handleMatches();\n                        } else {\n                            this.canPick = true;\n                            this.selectedGem = null;\n                        }\n                    }\n                }\n            }\n        });\n    }\n    matchInBoard() {\n        for(let i = 0; i < this.fieldSizeY; i++){\n            for(let j = 0; j < this.fieldSizeX; j++){\n                if (this.isMatch(i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    handleMatches() {\n        this.removeMap = [];\n        for(let i = 0; i < this.fieldSizeY; i++){\n            this.removeMap[i] = [];\n            for(let j = 0; j < this.fieldSizeX; j++){\n                this.removeMap[i].push(0);\n            }\n        }\n        this.markMatches(\"horizontal\");\n        this.markMatches(\"vertical\");\n        this.destroyGems();\n    }\n    markMatches(direction) {\n        let iMax = direction == \"horizontal\" ? this.fieldSizeY : this.fieldSizeX;\n        let jMax = direction == \"horizontal\" ? this.fieldSizeX : this.fieldSizeY;\n        for(let i = 0; i < iMax; i++){\n            let colorStreak = 1;\n            let currentColor = -1;\n            let startStreak = 0;\n            let colorToWatch = 0;\n            for(let j = 0; j < jMax; j++){\n                if (direction == \"horizontal\") {\n                    colorToWatch = this.gemAt(i, j).gemColor;\n                } else {\n                    colorToWatch = this.gemAt(j, i).gemColor;\n                }\n                if (colorToWatch == currentColor) {\n                    colorStreak++;\n                }\n                if (colorToWatch != currentColor || j == jMax - 1) {\n                    if (colorStreak >= 3) {\n                        if (direction == \"horizontal\") {\n                            console.log(\"HORIZONTAL :: Length = \" + colorStreak + \" :: Start = (\" + i + \",\" + startStreak + \") :: Color = \" + currentColor);\n                        } else {\n                            console.log(\"VERTICAL :: Length = \" + colorStreak + \" :: Start = (\" + startStreak + \",\" + i + \") :: Color = \" + currentColor);\n                        }\n                        for(let k = 0; k < colorStreak; k++){\n                            if (direction == \"horizontal\") {\n                                this.removeMap[i][startStreak + k]++;\n                            } else {\n                                this.removeMap[startStreak + k][i]++;\n                            }\n                        }\n                    }\n                    startStreak = j;\n                    colorStreak = 1;\n                    currentColor = colorToWatch;\n                }\n            }\n        }\n    }\n    destroyGems() {\n        let destroyed = 0;\n        for(let i = 0; i < this.fieldSizeY; i++){\n            for(let j = 0; j < this.fieldSizeX; j++){\n                if (this.removeMap[i][j] > 0) {\n                    destroyed++;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        alpha: 0.5,\n                        duration: this.destroySpeed,\n                        callbackScope: this,\n                        onComplete: function() {\n                            destroyed--;\n                            this.gameArray[i][j].gemSprite.visible = false;\n                            this.poolArray.push(this.gameArray[i][j].gemSprite);\n                            this.addScore(1);\n                            if (destroyed == 0) {\n                                this.makeGemsFall();\n                                this.replenishField();\n                            }\n                        }\n                    });\n                    this.gameArray[i][j].isEmpty = true;\n                }\n            }\n        }\n    }\n    makeGemsFall() {\n        for(let i = this.fieldSizeY - 2; i >= 0; i--){\n            for(let j = 0; j < this.fieldSizeX; j++){\n                if (!this.gameArray[i][j].isEmpty) {\n                    let fallTiles = this.holesBelow(i, j);\n                    if (fallTiles > 0) {\n                        this.scene.tweens.add({\n                            targets: this.gameArray[i][j].gemSprite,\n                            y: this.gameArray[i][j].gemSprite.y + fallTiles * this.gemSize,\n                            duration: this.fallSpeed * fallTiles\n                        });\n                        this.gameArray[i + fallTiles][j] = {\n                            gemSprite: this.gameArray[i][j].gemSprite,\n                            gemColor: this.gameArray[i][j].gemColor,\n                            isEmpty: false\n                        };\n                        this.gameArray[i][j].isEmpty = true;\n                    }\n                }\n            }\n        }\n    }\n    holesBelow(row, col) {\n        let result = 0;\n        for(let i = row + 1; i < this.fieldSizeY; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    replenishField() {\n        let replenished = 0;\n        for(let j = 0; j < this.fieldSizeX; j++){\n            let emptySpots = this.holesInCol(j);\n            if (emptySpots > 0) {\n                for(let i = 0; i < emptySpots; i++){\n                    replenished++;\n                    let randomColor = this.randomColor();\n                    this.gameArray[i][j].gemColor = randomColor;\n                    this.gameArray[i][j].gemSprite = this.poolArray.pop();\n                    this.gameArray[i][j].gemSprite.setTexture(randomColor);\n                    this.gameArray[i][j].gemSprite.visible = true;\n                    this.gameArray[i][j].gemSprite.x = this.startX + (this.gemSize * j + this.gemSize / 2);\n                    this.gameArray[i][j].gemSprite.y = this.startY + (this.gemSize / 2 - (emptySpots - i) * this.gemSize);\n                    this.gameArray[i][j].gemSprite.alpha = 1;\n                    this.gameArray[i][j].isEmpty = false;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        y: this.startY + (this.gemSize * i + this.gemSize / 2),\n                        duration: this.fallSpeed * emptySpots,\n                        callbackScope: this,\n                        onComplete: function() {\n                            replenished--;\n                            if (replenished == 0) {\n                                if (this.matchInBoard()) {\n                                    this.scene.time.addEvent({\n                                        delay: 250,\n                                        callback: this.handleMatches()\n                                    });\n                                } else {\n                                    this.canPick = true;\n                                    this.selectedGem = null;\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n    holesInCol(col) {\n        var result = 0;\n        for(let i = 0; i < this.fieldSizeY; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    randomColor() {\n        return this.gemColors[Phaser.Math.Between(0, this.gemColors.length - 1)];\n    }\n    addScore(value) {\n        this.score += value;\n        this.scoreText.setText(\"Score: \" + this.score);\n    }\n    constructor(scene, x, y){\n        this.startX = 0;\n        this.startY = 0;\n        //\n        this.fieldSize = 6;\n        this.fieldSizeX = 7;\n        this.fieldSizeY = 6;\n        this.gemSize = 128;\n        this.swapSpeed = 200;\n        this.fallSpeed = 100;\n        this.destroySpeed = 200;\n        this.gemColors = [\n            \"blue\",\n            \"green\",\n            \"orange\",\n            \"red\"\n        ];\n        //\n        this.canPick = true;\n        this.dragging = false;\n        //\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.scene = scene;\n        this.startX = x - this.fieldSizeX * this.gemSize / 2;\n        this.startY = y - this.fieldSizeY * this.gemSize / 2;\n        this.scoreText = this.scene.add.text(_lib_GameLib__WEBPACK_IMPORTED_MODULE_0__[\"default\"].screenWidth / 2, this.startY - 30, \"Score: \" + this.score);\n        this.drawField();\n        this.scene.input.on(\"pointerdown\", this.gemSelect, this);\n        this.scene.input.on(\"pointermove\", this.startSwipe, this);\n        this.scene.input.on(\"pointerup\", this.stopSwipe, this);\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWtCLEVBQUU7UUFXaEIsSUFBSSxDQUFDRSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDVSxNQUFNLEdBQUdELElBQUssSUFBSSxDQUFDSCxVQUFVLEdBQUMsSUFBSSxDQUFDSyxPQUFPLEdBQUU7UUFDakQsSUFBSSxDQUFDRSxNQUFNLEdBQUdELElBQUssSUFBSSxDQUFDUixVQUFVLEdBQUMsSUFBSSxDQUFDTyxPQUFPLEdBQUU7UUFFakQsSUFBSSxDQUFDbUcsU0FBUyxHQUFHLElBQUksQ0FBQzlHLEtBQUssQ0FBQ0MsR0FBRyxDQUFDaUgsSUFBSSxDQUFFMUgsZ0VBQW1CLEdBQUMsR0FBRyxJQUFJLENBQUNxQixNQUFNLEdBQUcsSUFBSSxZQUFZLElBQUksQ0FBQ2dHLEtBQUs7UUFFckcsSUFBSSxDQUFDbEgsU0FBUztRQUNkLElBQUksQ0FBQ0ssS0FBSyxDQUFDb0gsS0FBSyxDQUFDQyxFQUFFLENBQUMsZUFBZSxJQUFJLENBQUMzRixTQUFTLEVBQUUsSUFBSTtRQUN2RCxJQUFJLENBQUMxQixLQUFLLENBQUNvSCxLQUFLLENBQUNDLEVBQUUsQ0FBQyxlQUFlLElBQUksQ0FBQzlFLFVBQVUsRUFBRSxJQUFJO1FBQ3hELElBQUksQ0FBQ3ZDLEtBQUssQ0FBQ29ILEtBQUssQ0FBQ0MsRUFBRSxDQUFDLGFBQWEsSUFBSSxDQUFDcEUsU0FBUyxFQUFFLElBQUk7SUFDekQ7QUFtWEo7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZ2FtZS9jb21wb25lbnRzL01hdGNoLnRzPzg2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdhbWVMaWIgZnJvbSBcIkAvbGliL0dhbWVMaWJcIjtcbmltcG9ydCB7IEdhbWUsIEdhbWVPYmplY3RzLCBTY2VuZSB9IGZyb20gXCJwaGFzZXJcIjtcblxuY2xhc3MgR2Vte1xuICAgIGdlbUNvbG9yOiBzdHJpbmdcbiAgICBnZW1TcHJpdGU6IEdhbWVPYmplY3RzLlNwcml0ZVxuICAgIGlzRW1wdHk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0Y2h7XG5cbiAgICBzY2VuZTogUGhhc2VyLlNjZW5lXG4gICAgc3RhcnRYOiBudW1iZXIgPSAwXG4gICAgc3RhcnRZOiBudW1iZXIgPSAwXG4gICAgLy9cbiAgICBmaWVsZFNpemU6IG51bWJlciA9IDZcbiAgICBmaWVsZFNpemVYOiBudW1iZXIgPSA3XG4gICAgZmllbGRTaXplWTogbnVtYmVyID0gNlxuICAgIGdlbVNpemU6IG51bWJlciA9IDEyOFxuICAgIHN3YXBTcGVlZDogbnVtYmVyID0gMjAwXG4gICAgZmFsbFNwZWVkOiBudW1iZXIgPSAxMDBcbiAgICBkZXN0cm95U3BlZWQ6IG51bWJlciA9IDIwMFxuICAgIGdlbUNvbG9yczogc3RyaW5nW10gPSBbJ2JsdWUnLCdncmVlbicsJ29yYW5nZScsJ3JlZCddXG4gICAgLy9cbiAgICBjYW5QaWNrOiBib29sZWFuID0gdHJ1ZVxuICAgIGRyYWdnaW5nOiBib29sZWFuID0gZmFsc2VcbiAgICAvL1xuICAgIGdhbWVBcnJheTogYW55ID0gW11cbiAgICBwb29sQXJyYXk6IGFueSA9IFtdXG4gICAgaW5wdXRBcnJheTogYW55ID0gW11cbiAgICBnZW1Hcm91cDogR2FtZU9iamVjdHMuR3JvdXBcbiAgICAvL1xuICAgIHNlbGVjdGVkR2VtOiBHZW0gfCBudWxsXG4gICAgc3dhcHBpbmdHZW1zOiBudW1iZXJcbiAgICByZW1vdmVNYXA6IGFueVxuICAgIC8vXG4gICAgc2NvcmU6IG51bWJlclxuICAgIHNjb3JlVGV4dDogR2FtZU9iamVjdHMuVGV4dFxuXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCB4OiBudW1iZXIsIHk6IG51bWJlcil7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZVxuICAgICAgICB0aGlzLnN0YXJ0WCA9IHggLSAodGhpcy5maWVsZFNpemVYKnRoaXMuZ2VtU2l6ZSAvMikgXG4gICAgICAgIHRoaXMuc3RhcnRZID0geSAtICh0aGlzLmZpZWxkU2l6ZVkqdGhpcy5nZW1TaXplIC8yKSBcblxuICAgICAgICB0aGlzLnNjb3JlVGV4dCA9IHRoaXMuc2NlbmUuYWRkLnRleHQoIEdhbWVMaWIuc2NyZWVuV2lkdGgvMiwgdGhpcy5zdGFydFkgLSAzMCwgXCJTY29yZTogXCIgKyB0aGlzLnNjb3JlIClcblxuICAgICAgICB0aGlzLmRyYXdGaWVsZCgpO1xuICAgICAgICB0aGlzLnNjZW5lLmlucHV0Lm9uKFwicG9pbnRlcmRvd25cIiwgdGhpcy5nZW1TZWxlY3QsIHRoaXMpO1xuICAgICAgICB0aGlzLnNjZW5lLmlucHV0Lm9uKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5zdGFydFN3aXBlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY2VuZS5pbnB1dC5vbihcInBvaW50ZXJ1cFwiLCB0aGlzLnN0b3BTd2lwZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgZHJhd0ZpZWxkKCl7XG4gICAgICAgIHRoaXMuZ2FtZUFycmF5ID0gW107XG4gICAgICAgIHRoaXMucG9vbEFycmF5ID0gW107XG4gICAgICAgIHRoaXMuaW5wdXRBcnJheSA9IFtdO1xuICAgICAgICB0aGlzLmdlbUdyb3VwID0gdGhpcy5zY2VuZS5hZGQuZ3JvdXAoKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplWTsgaSArKyl7XG4gICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEFycmF5W2ldID0gW107XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemVYOyBqICsrKXtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKClcblxuICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zdGFydFggKyAodGhpcy5nZW1TaXplICogaiArIHRoaXMuZ2VtU2l6ZSAvIDIpXG4gICAgICAgICAgICAgICAgbGV0IHkgPSB0aGlzLnN0YXJ0WSArICh0aGlzLmdlbVNpemUgKiBpICsgdGhpcy5nZW1TaXplIC8gMilcbiAgICAgICAgICAgICAgICBsZXQgZ2VtID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKCB4ICwgeSwgY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZW1Hcm91cC5hZGQoZ2VtKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkb3tcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbUNvbG9yID0gdGhpcy5yYW5kb21Db2xvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW0uc2V0VGV4dHVyZShyYW5kb21Db2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VtQ29sb3I6IHJhbmRvbUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VtU3ByaXRlOiBnZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSh0aGlzLmlzTWF0Y2goaSwgaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNNYXRjaChyb3c6bnVtYmVyLCBjb2w6bnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsTWF0Y2gocm93LCBjb2wpIHx8IHRoaXMuaXNWZXJ0aWNhbE1hdGNoKHJvdywgY29sKTtcbiAgICB9XG5cbiAgICBpc0hvcml6b250YWxNYXRjaChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpOiBib29sZWFue1xuICAgICAgICByZXR1cm4gdGhpcy5nZW1BdChyb3csIGNvbCkuZ2VtQ29sb3IgPT0gdGhpcy5nZW1BdChyb3csIGNvbCAtIDEpLmdlbUNvbG9yICYmIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93LCBjb2wgLSAyKS5nZW1Db2xvcjtcbiAgICB9XG5cbiAgICBpc1ZlcnRpY2FsTWF0Y2gocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbUF0KHJvdywgY29sKS5nZW1Db2xvciA9PSB0aGlzLmdlbUF0KHJvdyAtIDEsIGNvbCkuZ2VtQ29sb3IgJiYgdGhpcy5nZW1BdChyb3csIGNvbCkuZ2VtQ29sb3IgPT0gdGhpcy5nZW1BdChyb3cgLSAyLCBjb2wpLmdlbUNvbG9yO1xuICAgIH1cbiAgICBcbiAgICBnZW1BdChyb3c6IG51bWJlciwgY29sOiBudW1iZXIpOiBhbnl7XG4gICAgICAgIGlmKHJvdyA8IDAgfHwgcm93ID49IHRoaXMuZmllbGRTaXplWSB8fCBjb2wgPCAwIHx8IGNvbCA+PSB0aGlzLmZpZWxkU2l6ZVgpe1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdhbWVBcnJheVtyb3ddW2NvbF07XG4gICAgfVxuXG4gICAgZ2VtU2VsZWN0KHBvaW50ZXI6IFBoYXNlci5JbnB1dC5Qb2ludGVyKXtcbiAgICAgICAgaWYodGhpcy5jYW5QaWNrKXtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoIChwb2ludGVyLnkgLSB0aGlzLnN0YXJ0WSkgLyB0aGlzLmdlbVNpemUpO1xuICAgICAgICAgICAgbGV0IGNvbCA9IE1hdGguZmxvb3IoIChwb2ludGVyLnggLSB0aGlzLnN0YXJ0WCkgLyB0aGlzLmdlbVNpemUpO1xuICAgICAgICAgICAgbGV0IHBpY2tlZEdlbSA9IHRoaXMuZ2VtQXQocm93LCBjb2wpXG4gICAgICAgICAgICBpZihwaWNrZWRHZW0gIT0gLTEpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2VsZWN0ZWRHZW0gPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMS4yKTtcbiAgICAgICAgICAgICAgICAgICAgcGlja2VkR2VtLmdlbVNwcml0ZS5zZXREZXB0aCgxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IHBpY2tlZEdlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5hcmVUaGVTYW1lKHBpY2tlZEdlbSwgdGhpcy5zZWxlY3RlZEdlbSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5hcmVOZXh0KHBpY2tlZEdlbSwgdGhpcy5zZWxlY3RlZEdlbSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcEdlbXModGhpcy5zZWxlY3RlZEdlbSwgcGlja2VkR2VtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja2VkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxLjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBwaWNrZWRHZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydFN3aXBlKHBvaW50ZXI6IFBoYXNlci5JbnB1dC5Qb2ludGVyKXtcbiAgICAgICAgaWYodGhpcy5kcmFnZ2luZyAmJiB0aGlzLnNlbGVjdGVkR2VtICE9IG51bGwpe1xuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IHBvaW50ZXIuZG93blggLSBwb2ludGVyLng7XG4gICAgICAgICAgICBsZXQgZGVsdGFZID0gcG9pbnRlci5kb3duWSAtIHBvaW50ZXIueTtcbiAgICAgICAgICAgIGxldCBkZWx0YVJvdyA9IDA7XG4gICAgICAgICAgICBsZXQgZGVsdGFDb2wgPSAwO1xuICAgICAgICAgICAgaWYoZGVsdGFYID4gdGhpcy5nZW1TaXplIC8gMiAmJiBNYXRoLmFicyhkZWx0YVkpIDwgdGhpcy5nZW1TaXplIC8gNCl7XG4gICAgICAgICAgICAgICAgZGVsdGFDb2wgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRlbHRhWCA8IC10aGlzLmdlbVNpemUgLyAyICYmIE1hdGguYWJzKGRlbHRhWSkgPCB0aGlzLmdlbVNpemUgLyA0KXtcbiAgICAgICAgICAgICAgICBkZWx0YUNvbCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWx0YVkgPiB0aGlzLmdlbVNpemUgLyAyICYmIE1hdGguYWJzKGRlbHRhWCkgPCB0aGlzLmdlbVNpemUgLyA0KXtcbiAgICAgICAgICAgICAgICBkZWx0YVJvdyA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVsdGFZIDwgLXRoaXMuZ2VtU2l6ZSAvIDIgJiYgTWF0aC5hYnMoZGVsdGFYKSA8IHRoaXMuZ2VtU2l6ZSAvIDQpe1xuICAgICAgICAgICAgICAgIGRlbHRhUm93ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRlbHRhUm93ICsgZGVsdGFDb2wgIT0gMCl7XG4gICAgICAgICAgICAgICAgbGV0IHBpY2tlZEdlbSA9IHRoaXMuZ2VtQXQodGhpcy5nZXRHZW1Sb3codGhpcy5zZWxlY3RlZEdlbSkgKyBkZWx0YVJvdywgdGhpcy5nZXRHZW1Db2wodGhpcy5zZWxlY3RlZEdlbSkgKyBkZWx0YUNvbCk7XG4gICAgICAgICAgICAgICAgaWYocGlja2VkR2VtICE9IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcEdlbXModGhpcy5zZWxlY3RlZEdlbSwgcGlja2VkR2VtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BTd2lwZSgpe1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYXJlVGhlU2FtZShnZW0xOiBHZW0sIGdlbTI6IEdlbSl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlbVJvdyhnZW0xKSA9PSB0aGlzLmdldEdlbVJvdyhnZW0yKSAmJiB0aGlzLmdldEdlbUNvbChnZW0xKSA9PSB0aGlzLmdldEdlbUNvbChnZW0yKTtcbiAgICB9XG5cbiAgICBnZXRHZW1Sb3coZ2VtOiBHZW0pe1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vciggKGdlbS5nZW1TcHJpdGUueSAtIHRoaXMuc3RhcnRZKSAvIHRoaXMuZ2VtU2l6ZSk7XG4gICAgfVxuXG4gICAgZ2V0R2VtQ29sKGdlbTogR2VtKXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoIChnZW0uZ2VtU3ByaXRlLnggLSB0aGlzLnN0YXJ0WCkgLyB0aGlzLmdlbVNpemUpO1xuICAgIH1cblxuICAgIGFyZU5leHQoZ2VtMTogR2VtLCBnZW0yOiBHZW0pe1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5nZXRHZW1Sb3coZ2VtMSkgLSB0aGlzLmdldEdlbVJvdyhnZW0yKSkgKyBNYXRoLmFicyh0aGlzLmdldEdlbUNvbChnZW0xKSAtIHRoaXMuZ2V0R2VtQ29sKGdlbTIpKSA9PSAxO1xuICAgIH1cblxuICAgIHN3YXBHZW1zKGdlbTE6IEdlbSwgZ2VtMjogR2VtLCBzd2FwQmFjazogYm9vbGVhbil7XG4gICAgICAgIHRoaXMuc3dhcHBpbmdHZW1zID0gMjtcbiAgICAgICAgdGhpcy5jYW5QaWNrID0gZmFsc2U7XG4gICAgICAgIGxldCBmcm9tQ29sb3IgPSBnZW0xLmdlbUNvbG9yO1xuICAgICAgICBsZXQgZnJvbVNwcml0ZSA9IGdlbTEuZ2VtU3ByaXRlO1xuICAgICAgICBsZXQgdG9Db2xvciA9IGdlbTIuZ2VtQ29sb3I7XG4gICAgICAgIGxldCB0b1Nwcml0ZSA9IGdlbTIuZ2VtU3ByaXRlO1xuICAgICAgICBsZXQgZ2VtMVJvdyA9IHRoaXMuZ2V0R2VtUm93KGdlbTEpO1xuICAgICAgICBsZXQgZ2VtMUNvbCA9IHRoaXMuZ2V0R2VtQ29sKGdlbTEpO1xuICAgICAgICBsZXQgZ2VtMlJvdyA9IHRoaXMuZ2V0R2VtUm93KGdlbTIpO1xuICAgICAgICBsZXQgZ2VtMkNvbCA9IHRoaXMuZ2V0R2VtQ29sKGdlbTIpO1xuICAgICAgICB0aGlzLmdhbWVBcnJheVtnZW0xUm93XVtnZW0xQ29sXS5nZW1Db2xvciA9IHRvQ29sb3I7XG4gICAgICAgIHRoaXMuZ2FtZUFycmF5W2dlbTFSb3ddW2dlbTFDb2xdLmdlbVNwcml0ZSA9IHRvU3ByaXRlO1xuICAgICAgICB0aGlzLmdhbWVBcnJheVtnZW0yUm93XVtnZW0yQ29sXS5nZW1Db2xvciA9IGZyb21Db2xvcjtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXlbZ2VtMlJvd11bZ2VtMkNvbF0uZ2VtU3ByaXRlID0gZnJvbVNwcml0ZTtcbiAgICAgICAgdGhpcy50d2VlbkdlbShnZW0xLCBnZW0yLCBzd2FwQmFjayk7XG4gICAgICAgIHRoaXMudHdlZW5HZW0oZ2VtMiwgZ2VtMSwgc3dhcEJhY2spO1xuICAgIH1cblxuICAgIHR3ZWVuR2VtKGdlbTE6IEdlbSwgZ2VtMjogR2VtLCBzd2FwQmFjazogYm9vbGVhbil7XG4gICAgICAgIGxldCByb3cgPSB0aGlzLmdldEdlbVJvdyhnZW0xKTtcbiAgICAgICAgbGV0IGNvbCA9IHRoaXMuZ2V0R2VtQ29sKGdlbTEpO1xuICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5nYW1lQXJyYXlbcm93XVtjb2xdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgIHg6IHRoaXMuc3RhcnRYICsgKGNvbCAqIHRoaXMuZ2VtU2l6ZSArIHRoaXMuZ2VtU2l6ZSAvIDIpLFxuICAgICAgICAgICAgeTogdGhpcy5zdGFydFkgKyAocm93ICogdGhpcy5nZW1TaXplICsgdGhpcy5nZW1TaXplIC8gMiksXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5zd2FwU3BlZWQsXG4gICAgICAgICAgICBjYWxsYmFja1Njb3BlOiB0aGlzLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXBwaW5nR2VtcyAtLTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnN3YXBwaW5nR2VtcyA9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMubWF0Y2hJbkJvYXJkKCkgJiYgc3dhcEJhY2spe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2FwR2VtcyhnZW0xLCBnZW0yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubWF0Y2hJbkJvYXJkKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTWF0Y2hlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblBpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtYXRjaEluQm9hcmQoKXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplWTsgaSArKyl7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemVYOyBqICsrKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzTWF0Y2goaSwgaikpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGhhbmRsZU1hdGNoZXMoKXtcbiAgICAgICAgdGhpcy5yZW1vdmVNYXAgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplWTsgaSArKyl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1hcFtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplWDsgaiArKyl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXBbaV0ucHVzaCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtNYXRjaGVzKCdob3Jpem9udGFsJyk7XG4gICAgICAgIHRoaXMubWFya01hdGNoZXMoJ3ZlcnRpY2FsJyk7XG4gICAgICAgIHRoaXMuZGVzdHJveUdlbXMoKTtcbiAgICB9XG5cbiAgICBtYXJrTWF0Y2hlcyhkaXJlY3Rpb246IHN0cmluZyl7XG4gICAgICAgIGxldCBpTWF4ID0gZGlyZWN0aW9uID09ICdob3Jpem9udGFsJz8gdGhpcy5maWVsZFNpemVZOnRoaXMuZmllbGRTaXplWFxuICAgICAgICBsZXQgak1heCA9IGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCc/IHRoaXMuZmllbGRTaXplWDp0aGlzLmZpZWxkU2l6ZVlcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGlNYXg7IGkgKyspe1xuICAgICAgICAgICAgbGV0IGNvbG9yU3RyZWFrID0gMTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29sb3IgPSAtMTtcbiAgICAgICAgICAgIGxldCBzdGFydFN0cmVhayA9IDA7XG4gICAgICAgICAgICBsZXQgY29sb3JUb1dhdGNoID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBqTWF4OyBqICsrKXtcbiAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKXtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JUb1dhdGNoID0gdGhpcy5nZW1BdChpLCBqKS5nZW1Db2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JUb1dhdGNoID0gdGhpcy5nZW1BdChqLCBpKS5nZW1Db2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoY29sb3JUb1dhdGNoID09IGN1cnJlbnRDb2xvcil7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RyZWFrICsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihjb2xvclRvV2F0Y2ggIT0gY3VycmVudENvbG9yIHx8IGogPT0gak1heCAtIDEpe1xuICAgICAgICAgICAgICAgICAgICBpZihjb2xvclN0cmVhayA+PSAzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSE9SSVpPTlRBTCA6OiBMZW5ndGggPSBcIiArIGNvbG9yU3RyZWFrICsgXCIgOjogU3RhcnQgPSAoXCIgKyBpICsgXCIsXCIgKyBzdGFydFN0cmVhayArIFwiKSA6OiBDb2xvciA9IFwiICsgY3VycmVudENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWRVJUSUNBTCA6OiBMZW5ndGggPSBcIiArIGNvbG9yU3RyZWFrICsgXCIgOjogU3RhcnQgPSAoXCIgKyBzdGFydFN0cmVhayArIFwiLFwiICsgaSArIFwiKSA6OiBDb2xvciA9IFwiICsgY3VycmVudENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgayA9IDA7IGsgPCBjb2xvclN0cmVhazsgayArKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwW2ldW3N0YXJ0U3RyZWFrICsga10gKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwW3N0YXJ0U3RyZWFrICsga11baV0gKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U3RyZWFrID0gajtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JTdHJlYWsgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29sb3IgPSBjb2xvclRvV2F0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveUdlbXMoKXtcbiAgICAgICAgbGV0IGRlc3Ryb3llZCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZVk7IGkgKyspe1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplWDsgaiArKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5yZW1vdmVNYXBbaV1bal0gPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVkICsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmRlc3Ryb3lTcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrU2NvcGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llZCAtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbEFycmF5LnB1c2godGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjb3JlKDEpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZXN0cm95ZWQgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZUdlbXNGYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGVuaXNoRmllbGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlR2Vtc0ZhbGwoKXtcbiAgICAgICAgZm9yKGxldCBpID0gdGhpcy5maWVsZFNpemVZIC0gMjsgaSA+PSAwOyBpIC0tKXtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZVg7IGogKyspe1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhbGxUaWxlcyA9IHRoaXMuaG9sZXNCZWxvdyhpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZmFsbFRpbGVzID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUueSArIGZhbGxUaWxlcyAqIHRoaXMuZ2VtU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5mYWxsU3BlZWQgKiBmYWxsVGlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaSArIGZhbGxUaWxlc11bal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VtU3ByaXRlOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VtQ29sb3I6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRW1wdHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvbGVzQmVsb3cocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKXtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IHJvdyArIDE7IGkgPCB0aGlzLmZpZWxkU2l6ZVk7IGkgKyspe1xuICAgICAgICAgICAgaWYodGhpcy5nYW1lQXJyYXlbaV1bY29sXS5pc0VtcHR5KXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXBsZW5pc2hGaWVsZCgpe1xuICAgICAgICBsZXQgcmVwbGVuaXNoZWQgPSAwO1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemVYOyBqICsrKXtcbiAgICAgICAgICAgIGxldCBlbXB0eVNwb3RzID0gdGhpcy5ob2xlc0luQ29sKGopO1xuICAgICAgICAgICAgaWYoZW1wdHlTcG90cyA+IDApe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbXB0eVNwb3RzOyBpICsrKXtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoZWQgKys7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5kb21Db2xvciA9IHRoaXMucmFuZG9tQ29sb3IoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1Db2xvciA9IHJhbmRvbUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUgPSB0aGlzLnBvb2xBcnJheS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUuc2V0VGV4dHVyZShyYW5kb21Db2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnggPSB0aGlzLnN0YXJ0WCArICh0aGlzLmdlbVNpemUgKiBqICsgdGhpcy5nZW1TaXplIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS55ID0gdGhpcy5zdGFydFkgKyAodGhpcy5nZW1TaXplIC8gMiAtIChlbXB0eVNwb3RzIC0gaSkgKiB0aGlzLmdlbVNpemUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUuYWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudHdlZW5zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnN0YXJ0WSArICh0aGlzLmdlbVNpemUgKiBpICsgdGhpcy5nZW1TaXplIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5mYWxsU3BlZWQgKiBlbXB0eVNwb3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoZWQgLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVwbGVuaXNoZWQgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubWF0Y2hJbkJvYXJkKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50aW1lLmFkZEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogMjUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLmhhbmRsZU1hdGNoZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9sZXNJbkNvbChjb2w6IG51bWJlcil7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemVZOyBpICsrKXtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2FtZUFycmF5W2ldW2NvbF0uaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmFuZG9tQ29sb3IoKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbUNvbG9yc1tQaGFzZXIuTWF0aC5CZXR3ZWVuKDAsIHRoaXMuZ2VtQ29sb3JzLmxlbmd0aCAtIDEpXTtcbiAgICB9XG5cbiAgICBhZGRTY29yZSh2YWx1ZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnNjb3JlICs9IHZhbHVlXG5cbiAgICAgICAgdGhpcy5zY29yZVRleHQuc2V0VGV4dChcIlNjb3JlOiBcIiArIHRoaXMuc2NvcmUgKVxuICAgIH1cbn0iXSwibmFtZXMiOlsiR2FtZUxpYiIsIkdlbSIsIk1hdGNoIiwiZHJhd0ZpZWxkIiwiZ2FtZUFycmF5IiwicG9vbEFycmF5IiwiaW5wdXRBcnJheSIsImdlbUdyb3VwIiwic2NlbmUiLCJhZGQiLCJncm91cCIsImkiLCJmaWVsZFNpemVZIiwiaiIsImZpZWxkU2l6ZVgiLCJjb2xvciIsInJhbmRvbUNvbG9yIiwieCIsInN0YXJ0WCIsImdlbVNpemUiLCJ5Iiwic3RhcnRZIiwiZ2VtIiwic3ByaXRlIiwic2V0VGV4dHVyZSIsImdlbUNvbG9yIiwiZ2VtU3ByaXRlIiwiaXNFbXB0eSIsImlzTWF0Y2giLCJyb3ciLCJjb2wiLCJpc0hvcml6b250YWxNYXRjaCIsImlzVmVydGljYWxNYXRjaCIsImdlbUF0IiwiZ2VtU2VsZWN0IiwicG9pbnRlciIsImNhblBpY2siLCJkcmFnZ2luZyIsIk1hdGgiLCJmbG9vciIsInBpY2tlZEdlbSIsInNlbGVjdGVkR2VtIiwic2V0U2NhbGUiLCJzZXREZXB0aCIsImFyZVRoZVNhbWUiLCJhcmVOZXh0Iiwic3dhcEdlbXMiLCJzdGFydFN3aXBlIiwiZGVsdGFYIiwiZG93blgiLCJkZWx0YVkiLCJkb3duWSIsImRlbHRhUm93IiwiZGVsdGFDb2wiLCJhYnMiLCJnZXRHZW1Sb3ciLCJnZXRHZW1Db2wiLCJzdG9wU3dpcGUiLCJnZW0xIiwiZ2VtMiIsInN3YXBCYWNrIiwic3dhcHBpbmdHZW1zIiwiZnJvbUNvbG9yIiwiZnJvbVNwcml0ZSIsInRvQ29sb3IiLCJ0b1Nwcml0ZSIsImdlbTFSb3ciLCJnZW0xQ29sIiwiZ2VtMlJvdyIsImdlbTJDb2wiLCJ0d2VlbkdlbSIsInR3ZWVucyIsInRhcmdldHMiLCJkdXJhdGlvbiIsInN3YXBTcGVlZCIsImNhbGxiYWNrU2NvcGUiLCJvbkNvbXBsZXRlIiwibWF0Y2hJbkJvYXJkIiwiaGFuZGxlTWF0Y2hlcyIsInJlbW92ZU1hcCIsInB1c2giLCJtYXJrTWF0Y2hlcyIsImRlc3Ryb3lHZW1zIiwiZGlyZWN0aW9uIiwiaU1heCIsImpNYXgiLCJjb2xvclN0cmVhayIsImN1cnJlbnRDb2xvciIsInN0YXJ0U3RyZWFrIiwiY29sb3JUb1dhdGNoIiwiY29uc29sZSIsImxvZyIsImsiLCJkZXN0cm95ZWQiLCJhbHBoYSIsImRlc3Ryb3lTcGVlZCIsInZpc2libGUiLCJhZGRTY29yZSIsIm1ha2VHZW1zRmFsbCIsInJlcGxlbmlzaEZpZWxkIiwiZmFsbFRpbGVzIiwiaG9sZXNCZWxvdyIsImZhbGxTcGVlZCIsInJlc3VsdCIsInJlcGxlbmlzaGVkIiwiZW1wdHlTcG90cyIsImhvbGVzSW5Db2wiLCJwb3AiLCJ0aW1lIiwiYWRkRXZlbnQiLCJkZWxheSIsImNhbGxiYWNrIiwiZ2VtQ29sb3JzIiwiUGhhc2VyIiwiQmV0d2VlbiIsImxlbmd0aCIsInZhbHVlIiwic2NvcmUiLCJzY29yZVRleHQiLCJzZXRUZXh0IiwiY29uc3RydWN0b3IiLCJmaWVsZFNpemUiLCJ0ZXh0Iiwic2NyZWVuV2lkdGgiLCJpbnB1dCIsIm9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/game/components/Match.ts\n"));

/***/ })

});