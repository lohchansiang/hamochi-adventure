"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_App_tsx",{

/***/ "./src/game/components/Match.ts":
/*!**************************************!*\
  !*** ./src/game/components/Match.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Match; }\n/* harmony export */ });\nclass Gem {\n}\nclass Match {\n    drawField() {\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.gemGroup = this.scene.add.group();\n        for(let i = 0; i < this.fieldSize; i++){\n            this.gameArray[i] = [];\n            for(let j = 0; j < this.fieldSize; j++){\n                let color = this.randomColor();\n                let gem = this.scene.add.sprite(this.startX + (this.gemSize * j + this.gemSize / 2), this.startY + (this.gemSize * i + this.gemSize / 2), color);\n                this.gemGroup.add(gem);\n                let gemData = {\n                    gemColor: color,\n                    gemSprite: gem,\n                    isEmpty: false\n                };\n                this.gameArray[i][j] = gemData;\n                gem.on(\"pointerdown\", (pointer)=>{\n                    this.gemSelect(pointer, gemData);\n                }, this);\n                gem.setInteractive();\n            }\n        }\n    }\n    isMatch(row, col) {\n        return this.isHorizontalMatch(row, col) || this.isVerticalMatch(row, col);\n    }\n    isHorizontalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row, col - 1).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row, col - 2).gemColor;\n    }\n    isVerticalMatch(row, col) {\n        return this.gemAt(row, col).gemColor == this.gemAt(row - 1, col).gemColor && this.gemAt(row, col).gemColor == this.gemAt(row - 2, col).gemColor;\n    }\n    gemAt(row, col) {\n        if (row < 0 || row >= this.fieldSize || col < 0 || col >= this.fieldSize) {\n            return -1;\n        }\n        return this.gameArray[row][col];\n    }\n    gemSelect(pointer, gem) {\n        if (this.canPick) {\n            this.dragging = true;\n            // let row = Math.floor(pointer.y / this.gemSize);\n            // let col = Math.floor(pointer.x / this.gemSize);\n            // let pickedGem = this.gemAt(row, col)\n            let pickedGem = gem;\n            if (pickedGem) {\n                if (this.selectedGem == null) {\n                    pickedGem.gemSprite.setScale(1.2);\n                    pickedGem.gemSprite.setDepth(1);\n                    this.selectedGem = pickedGem;\n                } else {\n                    if (this.areTheSame(pickedGem, this.selectedGem)) {\n                        this.selectedGem.gemSprite.setScale(1);\n                        this.selectedGem = null;\n                    } else {\n                        if (this.areNext(pickedGem, this.selectedGem)) {\n                            this.selectedGem.gemSprite.setScale(1);\n                            this.swapGems(this.selectedGem, pickedGem, true);\n                        } else {\n                            this.selectedGem.gemSprite.setScale(1);\n                            pickedGem.gemSprite.setScale(1.2);\n                            this.selectedGem = pickedGem;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    startSwipe(pointer) {\n        if (this.dragging && this.selectedGem != null) {\n            let deltaX = pointer.downX - pointer.x;\n            let deltaY = pointer.downY - pointer.y;\n            let deltaRow = 0;\n            let deltaCol = 0;\n            if (deltaX > this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = -1;\n            }\n            if (deltaX < -this.gemSize / 2 && Math.abs(deltaY) < this.gemSize / 4) {\n                deltaCol = 1;\n            }\n            if (deltaY > this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = -1;\n            }\n            if (deltaY < -this.gemSize / 2 && Math.abs(deltaX) < this.gemSize / 4) {\n                deltaRow = 1;\n            }\n            if (deltaRow + deltaCol != 0) {\n                let pickedGem = this.gemAt(this.getGemRow(this.selectedGem) + deltaRow, this.getGemCol(this.selectedGem) + deltaCol);\n                if (pickedGem != -1) {\n                    this.selectedGem.gemSprite.setScale(1);\n                    this.swapGems(this.selectedGem, pickedGem, true);\n                    this.dragging = false;\n                }\n            }\n        }\n    }\n    stopSwipe() {\n        this.dragging = false;\n    }\n    areTheSame(gem1, gem2) {\n        return this.getGemRow(gem1) == this.getGemRow(gem2) && this.getGemCol(gem1) == this.getGemCol(gem2);\n    }\n    getGemRow(gem) {\n        return Math.floor(gem.gemSprite.y / this.gemSize);\n    }\n    getGemCol(gem) {\n        return Math.floor(gem.gemSprite.x / this.gemSize);\n    }\n    areNext(gem1, gem2) {\n        return Math.abs(this.getGemRow(gem1) - this.getGemRow(gem2)) + Math.abs(this.getGemCol(gem1) - this.getGemCol(gem2)) == 1;\n    }\n    swapGems(gem1, gem2, swapBack) {\n        this.swappingGems = 2;\n        this.canPick = false;\n        let fromColor = gem1.gemColor;\n        let fromSprite = gem1.gemSprite;\n        let toColor = gem2.gemColor;\n        let toSprite = gem2.gemSprite;\n        let gem1Row = this.getGemRow(gem1);\n        let gem1Col = this.getGemCol(gem1);\n        let gem2Row = this.getGemRow(gem2);\n        let gem2Col = this.getGemCol(gem2);\n        this.gameArray[gem1Row][gem1Col].gemColor = toColor;\n        this.gameArray[gem1Row][gem1Col].gemSprite = toSprite;\n        this.gameArray[gem2Row][gem2Col].gemColor = fromColor;\n        this.gameArray[gem2Row][gem2Col].gemSprite = fromSprite;\n        this.tweenGem(gem1, gem2, swapBack);\n        this.tweenGem(gem2, gem1, swapBack);\n    }\n    tweenGem(gem1, gem2, swapBack) {\n        let row = this.getGemRow(gem1);\n        let col = this.getGemCol(gem1);\n        this.scene.tweens.add({\n            targets: this.gameArray[row][col].gemSprite,\n            x: col * this.gemSize + this.gemSize / 2,\n            y: row * this.gemSize + this.gemSize / 2,\n            duration: this.swapSpeed,\n            callbackScope: this,\n            onComplete: function() {\n                this.swappingGems--;\n                if (this.swappingGems == 0) {\n                    if (!this.matchInBoard() && swapBack) {\n                        this.swapGems(gem1, gem2, false);\n                    } else {\n                        if (this.matchInBoard()) {\n                            this.handleMatches();\n                        } else {\n                            this.canPick = true;\n                            this.selectedGem = null;\n                        }\n                    }\n                }\n            }\n        });\n    }\n    matchInBoard() {\n        for(let i = 0; i < this.fieldSize; i++){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (this.isMatch(i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    handleMatches() {\n        this.removeMap = [];\n        for(let i = 0; i < this.fieldSize; i++){\n            this.removeMap[i] = [];\n            for(let j = 0; j < this.fieldSize; j++){\n                this.removeMap[i].push(0);\n            }\n        }\n        this.markMatches(\"horizontal\");\n        this.markMatches(\"vertical\");\n        this.destroyGems();\n    }\n    markMatches(direction) {\n        for(let i = 0; i < this.fieldSize; i++){\n            let colorStreak = 1;\n            let currentColor = -1;\n            let startStreak = 0;\n            let colorToWatch = 0;\n            for(let j = 0; j < this.fieldSize; j++){\n                if (direction == \"horizontal\") {\n                    colorToWatch = this.gemAt(i, j).gemColor;\n                } else {\n                    colorToWatch = this.gemAt(j, i).gemColor;\n                }\n                if (colorToWatch == currentColor) {\n                    colorStreak++;\n                }\n                if (colorToWatch != currentColor || j == this.fieldSize - 1) {\n                    if (colorStreak >= 3) {\n                        if (direction == \"horizontal\") {\n                            console.log(\"HORIZONTAL :: Length = \" + colorStreak + \" :: Start = (\" + i + \",\" + startStreak + \") :: Color = \" + currentColor);\n                        } else {\n                            console.log(\"VERTICAL :: Length = \" + colorStreak + \" :: Start = (\" + startStreak + \",\" + i + \") :: Color = \" + currentColor);\n                        }\n                        for(let k = 0; k < colorStreak; k++){\n                            if (direction == \"horizontal\") {\n                                this.removeMap[i][startStreak + k]++;\n                            } else {\n                                this.removeMap[startStreak + k][i]++;\n                            }\n                        }\n                    }\n                    startStreak = j;\n                    colorStreak = 1;\n                    currentColor = colorToWatch;\n                }\n            }\n        }\n    }\n    destroyGems() {\n        let destroyed = 0;\n        for(let i = 0; i < this.fieldSize; i++){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (this.removeMap[i][j] > 0) {\n                    destroyed++;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        alpha: 0.5,\n                        duration: this.destroySpeed,\n                        callbackScope: this,\n                        onComplete: function() {\n                            destroyed--;\n                            this.gameArray[i][j].gemSprite.visible = false;\n                            this.poolArray.push(this.gameArray[i][j].gemSprite);\n                            if (destroyed == 0) {\n                                this.makeGemsFall();\n                                this.replenishField();\n                            }\n                        }\n                    });\n                    this.gameArray[i][j].isEmpty = true;\n                }\n            }\n        }\n    }\n    makeGemsFall() {\n        for(let i = this.fieldSize - 2; i >= 0; i--){\n            for(let j = 0; j < this.fieldSize; j++){\n                if (!this.gameArray[i][j].isEmpty) {\n                    let fallTiles = this.holesBelow(i, j);\n                    if (fallTiles > 0) {\n                        this.scene.tweens.add({\n                            targets: this.gameArray[i][j].gemSprite,\n                            y: this.gameArray[i][j].gemSprite.y + fallTiles * this.gemSize,\n                            duration: this.fallSpeed * fallTiles\n                        });\n                        this.gameArray[i + fallTiles][j] = {\n                            gemSprite: this.gameArray[i][j].gemSprite,\n                            gemColor: this.gameArray[i][j].gemColor,\n                            isEmpty: false\n                        };\n                        this.gameArray[i][j].isEmpty = true;\n                    }\n                }\n            }\n        }\n    }\n    holesBelow(row, col) {\n        let result = 0;\n        for(let i = row + 1; i < this.fieldSize; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    replenishField() {\n        let replenished = 0;\n        for(let j = 0; j < this.fieldSize; j++){\n            let emptySpots = this.holesInCol(j);\n            if (emptySpots > 0) {\n                for(let i = 0; i < emptySpots; i++){\n                    replenished++;\n                    let randomColor = this.randomColor();\n                    this.gameArray[i][j].gemColor = randomColor;\n                    this.gameArray[i][j].gemSprite = this.poolArray.pop();\n                    this.gameArray[i][j].gemSprite.setTexture(randomColor);\n                    this.gameArray[i][j].gemSprite.visible = true;\n                    this.gameArray[i][j].gemSprite.x = this.gemSize * j + this.gemSize / 2;\n                    this.gameArray[i][j].gemSprite.y = this.gemSize / 2 - (emptySpots - i) * this.gemSize;\n                    this.gameArray[i][j].gemSprite.alpha = 1;\n                    this.gameArray[i][j].isEmpty = false;\n                    this.scene.tweens.add({\n                        targets: this.gameArray[i][j].gemSprite,\n                        y: this.gemSize * i + this.gemSize / 2,\n                        duration: this.fallSpeed * emptySpots,\n                        callbackScope: this,\n                        onComplete: function() {\n                            replenished--;\n                            if (replenished == 0) {\n                                if (this.matchInBoard()) {\n                                    this.scene.time.addEvent({\n                                        delay: 250,\n                                        callback: this.handleMatches()\n                                    });\n                                } else {\n                                    this.canPick = true;\n                                    this.selectedGem = null;\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n    holesInCol(col) {\n        var result = 0;\n        for(let i = 0; i < this.fieldSize; i++){\n            if (this.gameArray[i][col].isEmpty) {\n                result++;\n            }\n        }\n        return result;\n    }\n    randomColor() {\n        return this.gemColors[Phaser.Math.Between(0, this.gemColors.length - 1)];\n    }\n    constructor(scene, x, y){\n        this.startX = 0;\n        this.startY = 0;\n        //\n        this.fieldSize = 7;\n        this.gemSize = 128;\n        this.swapSpeed = 200;\n        this.fallSpeed = 100;\n        this.destroySpeed = 200;\n        this.gemColors = [\n            \"blue\",\n            \"green\",\n            \"orange\",\n            \"red\"\n        ];\n        //\n        this.canPick = true;\n        this.dragging = false;\n        //\n        this.gameArray = [];\n        this.poolArray = [];\n        this.inputArray = [];\n        this.scene = scene;\n        // this.startX = x - (this.fieldSize*this.gemSize /2) \n        // this.startY = y - (this.fieldSize*this.gemSize /2) \n        this.drawField();\n        // this.scene.input.on(\"pointerdown\", this.gemSelect, this);\n        this.scene.input.on(\"pointermove\", this.startSwipe, this);\n        this.scene.input.on(\"pointerup\", this.stopSwipe, this);\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ2FtZS9jb21wb25lbnRzL01hdGNoLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFFQSxNQUFNQTtBQUlOO0FBRWUsTUFBTUM7SUFvQ2pCQyxZQUFXO1FBQ1AsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDQyxLQUFLLENBQUNDLEdBQUcsQ0FBQ0MsS0FBSztRQUNwQyxJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRUQsSUFBSztZQUNwQyxJQUFJLENBQUNQLFNBQVMsQ0FBQ08sRUFBRSxHQUFHLEVBQUU7WUFDdEIsSUFBSSxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDRCxTQUFTLEVBQUVDLElBQUs7Z0JBQ3BDLElBQUlDLFFBQVEsSUFBSSxDQUFDQyxXQUFXO2dCQUM1QixJQUFJQyxNQUFNLElBQUksQ0FBQ1IsS0FBSyxDQUFDQyxHQUFHLENBQUNRLE1BQU0sQ0FDZixJQUFJLENBQUNDLE1BQU0sR0FBSSxLQUFJLENBQUNDLE9BQU8sR0FBR04sSUFBSSxJQUFJLENBQUNNLE9BQU8sR0FBRyxJQUNqRCxJQUFJLENBQUNDLE1BQU0sR0FBSSxLQUFJLENBQUNELE9BQU8sR0FBR1IsSUFBSSxJQUFJLENBQUNRLE9BQU8sR0FBRyxJQUNqREw7Z0JBR2hCLElBQUksQ0FBQ1AsUUFBUSxDQUFDRSxHQUFHLENBQUNPO2dCQUVsQixJQUFJSyxVQUFlO29CQUNmQyxVQUFVUjtvQkFDVlMsV0FBV1A7b0JBQ1hRLFNBQVM7Z0JBQ2I7Z0JBQ0EsSUFBSSxDQUFDcEIsU0FBUyxDQUFDTyxFQUFFLENBQUNFLEVBQUUsR0FBR1E7Z0JBRXZCTCxJQUFJUyxFQUFFLENBQUMsZUFBZSxDQUFFQztvQkFDcEIsSUFBSSxDQUFDQyxTQUFTLENBQUNELFNBQVFMO2dCQUMzQixHQUFHLElBQUk7Z0JBRVBMLElBQUlZLGNBQWM7WUFDdEI7UUFDSjtJQUNKO0lBRUFDLFFBQVFDLEdBQVUsRUFBRUMsR0FBVSxFQUFVO1FBQ3BDLE9BQU8sSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0YsS0FBS0MsUUFBUSxJQUFJLENBQUNFLGVBQWUsQ0FBQ0gsS0FBS0M7SUFDekU7SUFFQUMsa0JBQWtCRixHQUFXLEVBQUVDLEdBQVcsRUFBVTtRQUNoRCxPQUFPLElBQUksQ0FBQ0csS0FBSyxDQUFDSixLQUFLQyxLQUFLVCxRQUFRLElBQUksSUFBSSxDQUFDWSxLQUFLLENBQUNKLEtBQUtDLE1BQU0sR0FBR1QsUUFBUSxJQUFJLElBQUksQ0FBQ1ksS0FBSyxDQUFDSixLQUFLQyxLQUFLVCxRQUFRLElBQUksSUFBSSxDQUFDWSxLQUFLLENBQUNKLEtBQUtDLE1BQU0sR0FBR1QsUUFBUTtJQUNuSjtJQUVBVyxnQkFBZ0JILEdBQVcsRUFBRUMsR0FBVyxFQUFVO1FBQzFDLE9BQU8sSUFBSSxDQUFDRyxLQUFLLENBQUNKLEtBQUtDLEtBQUtULFFBQVEsSUFBSSxJQUFJLENBQUNZLEtBQUssQ0FBQ0osTUFBTSxHQUFHQyxLQUFLVCxRQUFRLElBQUksSUFBSSxDQUFDWSxLQUFLLENBQUNKLEtBQUtDLEtBQUtULFFBQVEsSUFBSSxJQUFJLENBQUNZLEtBQUssQ0FBQ0osTUFBTSxHQUFHQyxLQUFLVCxRQUFRO0lBQ3ZKO0lBRUFZLE1BQU1KLEdBQVcsRUFBRUMsR0FBVyxFQUFNO1FBQ2hDLElBQUdELE1BQU0sS0FBS0EsT0FBTyxJQUFJLENBQUNsQixTQUFTLElBQUltQixNQUFNLEtBQUtBLE9BQU8sSUFBSSxDQUFDbkIsU0FBUyxFQUFDO1lBQ3BFLE9BQU8sQ0FBQztRQUNaO1FBQ0EsT0FBTyxJQUFJLENBQUNSLFNBQVMsQ0FBQzBCLElBQUksQ0FBQ0MsSUFBSTtJQUNuQztJQUVBSixVQUFVRCxPQUE2QixFQUFFVixHQUFPLEVBQUM7UUFDN0MsSUFBRyxJQUFJLENBQUNtQixPQUFPLEVBQUM7WUFDWixJQUFJLENBQUNDLFFBQVEsR0FBRztZQUNoQixrREFBa0Q7WUFDbEQsa0RBQWtEO1lBQ2xELHVDQUF1QztZQUN2QyxJQUFJQyxZQUFZckI7WUFDaEIsSUFBR3FCLFdBQVU7Z0JBQ1QsSUFBRyxJQUFJLENBQUNDLFdBQVcsSUFBSSxNQUFLO29CQUN4QkQsVUFBVWQsU0FBUyxDQUFDZ0IsUUFBUSxDQUFDO29CQUM3QkYsVUFBVWQsU0FBUyxDQUFDaUIsUUFBUSxDQUFDO29CQUM3QixJQUFJLENBQUNGLFdBQVcsR0FBR0Q7Z0JBQ3ZCLE9BQ0k7b0JBQ0EsSUFBRyxJQUFJLENBQUNJLFVBQVUsQ0FBQ0osV0FBVyxJQUFJLENBQUNDLFdBQVcsR0FBRTt3QkFDNUMsSUFBSSxDQUFDQSxXQUFXLENBQUNmLFNBQVMsQ0FBQ2dCLFFBQVEsQ0FBQzt3QkFDcEMsSUFBSSxDQUFDRCxXQUFXLEdBQUc7b0JBQ3ZCLE9BQ0k7d0JBQ0EsSUFBRyxJQUFJLENBQUNJLE9BQU8sQ0FBQ0wsV0FBVyxJQUFJLENBQUNDLFdBQVcsR0FBRTs0QkFDekMsSUFBSSxDQUFDQSxXQUFXLENBQUNmLFNBQVMsQ0FBQ2dCLFFBQVEsQ0FBQzs0QkFDcEMsSUFBSSxDQUFDSSxRQUFRLENBQUMsSUFBSSxDQUFDTCxXQUFXLEVBQUVELFdBQVc7d0JBQy9DLE9BQ0k7NEJBQ0EsSUFBSSxDQUFDQyxXQUFXLENBQUNmLFNBQVMsQ0FBQ2dCLFFBQVEsQ0FBQzs0QkFDcENGLFVBQVVkLFNBQVMsQ0FBQ2dCLFFBQVEsQ0FBQzs0QkFDN0IsSUFBSSxDQUFDRCxXQUFXLEdBQUdEO3dCQUN2QjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUVBTyxXQUFXbEIsT0FBNkIsRUFBQztRQUNyQyxJQUFHLElBQUksQ0FBQ1UsUUFBUSxJQUFJLElBQUksQ0FBQ0UsV0FBVyxJQUFJLE1BQUs7WUFDekMsSUFBSU8sU0FBU25CLFFBQVFvQixLQUFLLEdBQUdwQixRQUFRcUIsQ0FBQztZQUN0QyxJQUFJQyxTQUFTdEIsUUFBUXVCLEtBQUssR0FBR3ZCLFFBQVF3QixDQUFDO1lBQ3RDLElBQUlDLFdBQVc7WUFDZixJQUFJQyxXQUFXO1lBQ2YsSUFBR1AsU0FBUyxJQUFJLENBQUMxQixPQUFPLEdBQUcsS0FBS2tDLEtBQUtDLEdBQUcsQ0FBQ04sVUFBVSxJQUFJLENBQUM3QixPQUFPLEdBQUcsR0FBRTtnQkFDaEVpQyxXQUFXLENBQUM7WUFDaEI7WUFDQSxJQUFHUCxTQUFTLENBQUMsSUFBSSxDQUFDMUIsT0FBTyxHQUFHLEtBQUtrQyxLQUFLQyxHQUFHLENBQUNOLFVBQVUsSUFBSSxDQUFDN0IsT0FBTyxHQUFHLEdBQUU7Z0JBQ2pFaUMsV0FBVztZQUNmO1lBQ0EsSUFBR0osU0FBUyxJQUFJLENBQUM3QixPQUFPLEdBQUcsS0FBS2tDLEtBQUtDLEdBQUcsQ0FBQ1QsVUFBVSxJQUFJLENBQUMxQixPQUFPLEdBQUcsR0FBRTtnQkFDaEVnQyxXQUFXLENBQUM7WUFDaEI7WUFDQSxJQUFHSCxTQUFTLENBQUMsSUFBSSxDQUFDN0IsT0FBTyxHQUFHLEtBQUtrQyxLQUFLQyxHQUFHLENBQUNULFVBQVUsSUFBSSxDQUFDMUIsT0FBTyxHQUFHLEdBQUU7Z0JBQ2pFZ0MsV0FBVztZQUNmO1lBQ0EsSUFBR0EsV0FBV0MsWUFBWSxHQUFFO2dCQUN4QixJQUFJZixZQUFZLElBQUksQ0FBQ0gsS0FBSyxDQUFDLElBQUksQ0FBQ3FCLFNBQVMsQ0FBQyxJQUFJLENBQUNqQixXQUFXLElBQUlhLFVBQVUsSUFBSSxDQUFDSyxTQUFTLENBQUMsSUFBSSxDQUFDbEIsV0FBVyxJQUFJYztnQkFDM0csSUFBR2YsYUFBYSxDQUFDLEdBQUU7b0JBQ2YsSUFBSSxDQUFDQyxXQUFXLENBQUNmLFNBQVMsQ0FBQ2dCLFFBQVEsQ0FBQztvQkFDcEMsSUFBSSxDQUFDSSxRQUFRLENBQUMsSUFBSSxDQUFDTCxXQUFXLEVBQUVELFdBQVc7b0JBQzNDLElBQUksQ0FBQ0QsUUFBUSxHQUFHO2dCQUNwQjtZQUNKO1FBQ0o7SUFDSjtJQUVBcUIsWUFBVztRQUNQLElBQUksQ0FBQ3JCLFFBQVEsR0FBRztJQUNwQjtJQUVBSyxXQUFXaUIsSUFBUyxFQUFFQyxJQUFTLEVBQUM7UUFDNUIsT0FBTyxJQUFJLENBQUNKLFNBQVMsQ0FBQ0csU0FBUyxJQUFJLENBQUNILFNBQVMsQ0FBQ0ksU0FBUyxJQUFJLENBQUNILFNBQVMsQ0FBQ0UsU0FBUyxJQUFJLENBQUNGLFNBQVMsQ0FBQ0c7SUFDbEc7SUFFQUosVUFBVXZDLEdBQVEsRUFBQztRQUNmLE9BQU9xQyxLQUFLTyxLQUFLLENBQUM1QyxJQUFJTyxTQUFTLENBQUMyQixDQUFDLEdBQUcsSUFBSSxDQUFDL0IsT0FBTztJQUNwRDtJQUVBcUMsVUFBVXhDLEdBQVEsRUFBQztRQUNmLE9BQU9xQyxLQUFLTyxLQUFLLENBQUM1QyxJQUFJTyxTQUFTLENBQUN3QixDQUFDLEdBQUcsSUFBSSxDQUFDNUIsT0FBTztJQUNwRDtJQUVBdUIsUUFBUWdCLElBQVMsRUFBRUMsSUFBUyxFQUFDO1FBQ3pCLE9BQU9OLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0csUUFBUSxJQUFJLENBQUNILFNBQVMsQ0FBQ0ksU0FBU04sS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0UsU0FBUyxDQUFDRSxRQUFRLElBQUksQ0FBQ0YsU0FBUyxDQUFDRyxVQUFVO0lBQzVIO0lBRUFoQixTQUFTZSxJQUFTLEVBQUVDLElBQVMsRUFBRUUsUUFBaUIsRUFBQztRQUM3QyxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUMzQixPQUFPLEdBQUc7UUFDZixJQUFJNEIsWUFBWUwsS0FBS3BDLFFBQVE7UUFDN0IsSUFBSTBDLGFBQWFOLEtBQUtuQyxTQUFTO1FBQy9CLElBQUkwQyxVQUFVTixLQUFLckMsUUFBUTtRQUMzQixJQUFJNEMsV0FBV1AsS0FBS3BDLFNBQVM7UUFDN0IsSUFBSTRDLFVBQVUsSUFBSSxDQUFDWixTQUFTLENBQUNHO1FBQzdCLElBQUlVLFVBQVUsSUFBSSxDQUFDWixTQUFTLENBQUNFO1FBQzdCLElBQUlXLFVBQVUsSUFBSSxDQUFDZCxTQUFTLENBQUNJO1FBQzdCLElBQUlXLFVBQVUsSUFBSSxDQUFDZCxTQUFTLENBQUNHO1FBQzdCLElBQUksQ0FBQ3ZELFNBQVMsQ0FBQytELFFBQVEsQ0FBQ0MsUUFBUSxDQUFDOUMsUUFBUSxHQUFHMkM7UUFDNUMsSUFBSSxDQUFDN0QsU0FBUyxDQUFDK0QsUUFBUSxDQUFDQyxRQUFRLENBQUM3QyxTQUFTLEdBQUcyQztRQUM3QyxJQUFJLENBQUM5RCxTQUFTLENBQUNpRSxRQUFRLENBQUNDLFFBQVEsQ0FBQ2hELFFBQVEsR0FBR3lDO1FBQzVDLElBQUksQ0FBQzNELFNBQVMsQ0FBQ2lFLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDL0MsU0FBUyxHQUFHeUM7UUFDN0MsSUFBSSxDQUFDTyxRQUFRLENBQUNiLE1BQU1DLE1BQU1FO1FBQzFCLElBQUksQ0FBQ1UsUUFBUSxDQUFDWixNQUFNRCxNQUFNRztJQUM5QjtJQUVBVSxTQUFTYixJQUFTLEVBQUVDLElBQVMsRUFBRUUsUUFBaUIsRUFBQztRQUM3QyxJQUFJL0IsTUFBTSxJQUFJLENBQUN5QixTQUFTLENBQUNHO1FBQ3pCLElBQUkzQixNQUFNLElBQUksQ0FBQ3lCLFNBQVMsQ0FBQ0U7UUFDekIsSUFBSSxDQUFDbEQsS0FBSyxDQUFDZ0UsTUFBTSxDQUFDL0QsR0FBRyxDQUFDO1lBQ2xCZ0UsU0FBUyxJQUFJLENBQUNyRSxTQUFTLENBQUMwQixJQUFJLENBQUNDLElBQUksQ0FBQ1IsU0FBUztZQUMzQ3dCLEdBQUdoQixNQUFNLElBQUksQ0FBQ1osT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxHQUFHO1lBQ3ZDK0IsR0FBR3BCLE1BQU0sSUFBSSxDQUFDWCxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLEdBQUc7WUFDdkN1RCxVQUFVLElBQUksQ0FBQ0MsU0FBUztZQUN4QkMsZUFBZSxJQUFJO1lBQ25CQyxZQUFZO2dCQUNSLElBQUksQ0FBQ2YsWUFBWTtnQkFDakIsSUFBRyxJQUFJLENBQUNBLFlBQVksSUFBSSxHQUFFO29CQUN0QixJQUFHLENBQUMsSUFBSSxDQUFDZ0IsWUFBWSxNQUFNakIsVUFBUzt3QkFDaEMsSUFBSSxDQUFDbEIsUUFBUSxDQUFDZSxNQUFNQyxNQUFNO29CQUM5QixPQUNJO3dCQUNBLElBQUcsSUFBSSxDQUFDbUIsWUFBWSxJQUFHOzRCQUNuQixJQUFJLENBQUNDLGFBQWE7d0JBQ3RCLE9BQ0k7NEJBQ0EsSUFBSSxDQUFDNUMsT0FBTyxHQUFHOzRCQUNmLElBQUksQ0FBQ0csV0FBVyxHQUFHO3dCQUN2QjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUVBd0MsZUFBYztRQUNWLElBQUksSUFBSW5FLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRUQsSUFBSztZQUNwQyxJQUFJLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNELFNBQVMsRUFBRUMsSUFBSztnQkFDcEMsSUFBRyxJQUFJLENBQUNnQixPQUFPLENBQUNsQixHQUFHRSxJQUFHO29CQUNsQixPQUFPO2dCQUNYO1lBQ0o7UUFDSjtRQUNBLE9BQU87SUFDWDtJQUVBa0UsZ0JBQWU7UUFDWCxJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksSUFBSXJFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRUQsSUFBSztZQUNwQyxJQUFJLENBQUNxRSxTQUFTLENBQUNyRSxFQUFFLEdBQUcsRUFBRTtZQUN0QixJQUFJLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNELFNBQVMsRUFBRUMsSUFBSztnQkFDcEMsSUFBSSxDQUFDbUUsU0FBUyxDQUFDckUsRUFBRSxDQUFDc0UsSUFBSSxDQUFDO1lBQzNCO1FBQ0o7UUFDQSxJQUFJLENBQUNDLFdBQVcsQ0FBQztRQUNqQixJQUFJLENBQUNBLFdBQVcsQ0FBQztRQUNqQixJQUFJLENBQUNDLFdBQVc7SUFDcEI7SUFFQUQsWUFBWUUsU0FBaUIsRUFBQztRQUMxQixJQUFJLElBQUl6RSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUVELElBQUs7WUFDcEMsSUFBSTBFLGNBQWM7WUFDbEIsSUFBSUMsZUFBZSxDQUFDO1lBQ3BCLElBQUlDLGNBQWM7WUFDbEIsSUFBSUMsZUFBZTtZQUNuQixJQUFJLElBQUkzRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDRCxTQUFTLEVBQUVDLElBQUs7Z0JBQ3BDLElBQUd1RSxhQUFhLGNBQWE7b0JBQ3pCSSxlQUFlLElBQUksQ0FBQ3RELEtBQUssQ0FBQ3ZCLEdBQUdFLEdBQUdTLFFBQVE7Z0JBQzVDLE9BQ0k7b0JBQ0FrRSxlQUFlLElBQUksQ0FBQ3RELEtBQUssQ0FBQ3JCLEdBQUdGLEdBQUdXLFFBQVE7Z0JBQzVDO2dCQUNBLElBQUdrRSxnQkFBZ0JGLGNBQWE7b0JBQzVCRDtnQkFDSjtnQkFDQSxJQUFHRyxnQkFBZ0JGLGdCQUFnQnpFLEtBQUssSUFBSSxDQUFDRCxTQUFTLEdBQUcsR0FBRTtvQkFDdkQsSUFBR3lFLGVBQWUsR0FBRTt3QkFDaEIsSUFBR0QsYUFBYSxjQUFhOzRCQUN6QkssUUFBUUMsR0FBRyxDQUFDLDRCQUE0QkwsY0FBYyxrQkFBa0IxRSxJQUFJLE1BQU00RSxjQUFjLGtCQUFrQkQ7d0JBQ3RILE9BQ0k7NEJBQ0FHLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJMLGNBQWMsa0JBQWtCRSxjQUFjLE1BQU01RSxJQUFJLGtCQUFrQjJFO3dCQUNwSDt3QkFDQSxJQUFJLElBQUlLLElBQUksR0FBR0EsSUFBSU4sYUFBYU0sSUFBSzs0QkFDakMsSUFBR1AsYUFBYSxjQUFhO2dDQUN6QixJQUFJLENBQUNKLFNBQVMsQ0FBQ3JFLEVBQUUsQ0FBQzRFLGNBQWNJLEVBQUU7NEJBQ3RDLE9BQ0k7Z0NBQ0EsSUFBSSxDQUFDWCxTQUFTLENBQUNPLGNBQWNJLEVBQUUsQ0FBQ2hGLEVBQUU7NEJBQ3RDO3dCQUNKO29CQUNKO29CQUNBNEUsY0FBYzFFO29CQUNkd0UsY0FBYztvQkFDZEMsZUFBZUU7Z0JBQ25CO1lBQ0o7UUFDSjtJQUNKO0lBRUFMLGNBQWE7UUFDVCxJQUFJUyxZQUFZO1FBQ2hCLElBQUksSUFBSWpGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRUQsSUFBSztZQUNwQyxJQUFJLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNELFNBQVMsRUFBRUMsSUFBSztnQkFDcEMsSUFBRyxJQUFJLENBQUNtRSxTQUFTLENBQUNyRSxFQUFFLENBQUNFLEVBQUUsR0FBRyxHQUFFO29CQUN4QitFO29CQUNBLElBQUksQ0FBQ3BGLEtBQUssQ0FBQ2dFLE1BQU0sQ0FBQy9ELEdBQUcsQ0FBQzt3QkFDbEJnRSxTQUFTLElBQUksQ0FBQ3JFLFNBQVMsQ0FBQ08sRUFBRSxDQUFDRSxFQUFFLENBQUNVLFNBQVM7d0JBQ3ZDc0UsT0FBTzt3QkFDUG5CLFVBQVUsSUFBSSxDQUFDb0IsWUFBWTt3QkFDM0JsQixlQUFlLElBQUk7d0JBQ25CQyxZQUFZOzRCQUNSZTs0QkFDQSxJQUFJLENBQUN4RixTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTLENBQUN3RSxPQUFPLEdBQUc7NEJBQ3pDLElBQUksQ0FBQzFGLFNBQVMsQ0FBQzRFLElBQUksQ0FBQyxJQUFJLENBQUM3RSxTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTOzRCQUNsRCxJQUFHcUUsYUFBYSxHQUFFO2dDQUNkLElBQUksQ0FBQ0ksWUFBWTtnQ0FDakIsSUFBSSxDQUFDQyxjQUFjOzRCQUN2Qjt3QkFDSjtvQkFDSjtvQkFDQSxJQUFJLENBQUM3RixTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVyxPQUFPLEdBQUc7Z0JBQ25DO1lBQ0o7UUFDSjtJQUNKO0lBRUF3RSxlQUFjO1FBQ1YsSUFBSSxJQUFJckYsSUFBSSxJQUFJLENBQUNDLFNBQVMsR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDekMsSUFBSSxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDRCxTQUFTLEVBQUVDLElBQUs7Z0JBQ3BDLElBQUcsQ0FBQyxJQUFJLENBQUNULFNBQVMsQ0FBQ08sRUFBRSxDQUFDRSxFQUFFLENBQUNXLE9BQU8sRUFBQztvQkFDN0IsSUFBSTBFLFlBQVksSUFBSSxDQUFDQyxVQUFVLENBQUN4RixHQUFHRTtvQkFDbkMsSUFBR3FGLFlBQVksR0FBRTt3QkFDYixJQUFJLENBQUMxRixLQUFLLENBQUNnRSxNQUFNLENBQUMvRCxHQUFHLENBQUM7NEJBQ2xCZ0UsU0FBUyxJQUFJLENBQUNyRSxTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTOzRCQUN2QzJCLEdBQUcsSUFBSSxDQUFDOUMsU0FBUyxDQUFDTyxFQUFFLENBQUNFLEVBQUUsQ0FBQ1UsU0FBUyxDQUFDMkIsQ0FBQyxHQUFHZ0QsWUFBWSxJQUFJLENBQUMvRSxPQUFPOzRCQUM5RHVELFVBQVUsSUFBSSxDQUFDMEIsU0FBUyxHQUFHRjt3QkFDL0I7d0JBQ0EsSUFBSSxDQUFDOUYsU0FBUyxDQUFDTyxJQUFJdUYsVUFBVSxDQUFDckYsRUFBRSxHQUFHOzRCQUMvQlUsV0FBVyxJQUFJLENBQUNuQixTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTOzRCQUN6Q0QsVUFBVSxJQUFJLENBQUNsQixTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDUyxRQUFROzRCQUN2Q0UsU0FBUzt3QkFDYjt3QkFDQSxJQUFJLENBQUNwQixTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVyxPQUFPLEdBQUc7b0JBQ25DO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBRUEyRSxXQUFXckUsR0FBVyxFQUFFQyxHQUFXLEVBQUM7UUFDaEMsSUFBSXNFLFNBQVM7UUFDYixJQUFJLElBQUkxRixJQUFJbUIsTUFBTSxHQUFHbkIsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRUQsSUFBSztZQUMxQyxJQUFHLElBQUksQ0FBQ1AsU0FBUyxDQUFDTyxFQUFFLENBQUNvQixJQUFJLENBQUNQLE9BQU8sRUFBQztnQkFDOUI2RTtZQUNKO1FBQ0o7UUFDQSxPQUFPQTtJQUNYO0lBRUFKLGlCQUFnQjtRQUNaLElBQUlLLGNBQWM7UUFDbEIsSUFBSSxJQUFJekYsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0QsU0FBUyxFQUFFQyxJQUFLO1lBQ3BDLElBQUkwRixhQUFhLElBQUksQ0FBQ0MsVUFBVSxDQUFDM0Y7WUFDakMsSUFBRzBGLGFBQWEsR0FBRTtnQkFDZCxJQUFJLElBQUk1RixJQUFJLEdBQUdBLElBQUk0RixZQUFZNUYsSUFBSztvQkFDaEMyRjtvQkFDQSxJQUFJdkYsY0FBYyxJQUFJLENBQUNBLFdBQVc7b0JBQ2xDLElBQUksQ0FBQ1gsU0FBUyxDQUFDTyxFQUFFLENBQUNFLEVBQUUsQ0FBQ1MsUUFBUSxHQUFHUDtvQkFDaEMsSUFBSSxDQUFDWCxTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTLEdBQUcsSUFBSSxDQUFDbEIsU0FBUyxDQUFDb0csR0FBRztvQkFDbkQsSUFBSSxDQUFDckcsU0FBUyxDQUFDTyxFQUFFLENBQUNFLEVBQUUsQ0FBQ1UsU0FBUyxDQUFDbUYsVUFBVSxDQUFDM0Y7b0JBQzFDLElBQUksQ0FBQ1gsU0FBUyxDQUFDTyxFQUFFLENBQUNFLEVBQUUsQ0FBQ1UsU0FBUyxDQUFDd0UsT0FBTyxHQUFHO29CQUN6QyxJQUFJLENBQUMzRixTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTLENBQUN3QixDQUFDLEdBQUcsSUFBSSxDQUFDNUIsT0FBTyxHQUFHTixJQUFJLElBQUksQ0FBQ00sT0FBTyxHQUFHO29CQUNyRSxJQUFJLENBQUNmLFNBQVMsQ0FBQ08sRUFBRSxDQUFDRSxFQUFFLENBQUNVLFNBQVMsQ0FBQzJCLENBQUMsR0FBRyxJQUFJLENBQUMvQixPQUFPLEdBQUcsSUFBSSxDQUFDb0YsYUFBYTVGLENBQUFBLElBQUssSUFBSSxDQUFDUSxPQUFPO29CQUNyRixJQUFJLENBQUNmLFNBQVMsQ0FBQ08sRUFBRSxDQUFDRSxFQUFFLENBQUNVLFNBQVMsQ0FBQ3NFLEtBQUssR0FBRztvQkFDdkMsSUFBSSxDQUFDekYsU0FBUyxDQUFDTyxFQUFFLENBQUNFLEVBQUUsQ0FBQ1csT0FBTyxHQUFHO29CQUMvQixJQUFJLENBQUNoQixLQUFLLENBQUNnRSxNQUFNLENBQUMvRCxHQUFHLENBQUM7d0JBQ2xCZ0UsU0FBUyxJQUFJLENBQUNyRSxTQUFTLENBQUNPLEVBQUUsQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTO3dCQUN2QzJCLEdBQUcsSUFBSSxDQUFDL0IsT0FBTyxHQUFHUixJQUFJLElBQUksQ0FBQ1EsT0FBTyxHQUFHO3dCQUNyQ3VELFVBQVUsSUFBSSxDQUFDMEIsU0FBUyxHQUFHRzt3QkFDM0IzQixlQUFlLElBQUk7d0JBQ25CQyxZQUFZOzRCQUNSeUI7NEJBQ0EsSUFBR0EsZUFBZSxHQUFFO2dDQUNoQixJQUFHLElBQUksQ0FBQ3hCLFlBQVksSUFBRztvQ0FDbkIsSUFBSSxDQUFDdEUsS0FBSyxDQUFDbUcsSUFBSSxDQUFDQyxRQUFRLENBQUM7d0NBQ3JCQyxPQUFPO3dDQUNQQyxVQUFVLElBQUksQ0FBQy9CLGFBQWE7b0NBQ2hDO2dDQUNKLE9BQ0k7b0NBQ0EsSUFBSSxDQUFDNUMsT0FBTyxHQUFHO29DQUNmLElBQUksQ0FBQ0csV0FBVyxHQUFHO2dDQUN2Qjs0QkFDSjt3QkFDSjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUVBa0UsV0FBV3pFLEdBQVcsRUFBQztRQUNuQixJQUFJc0UsU0FBUztRQUNiLElBQUksSUFBSTFGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRUQsSUFBSztZQUNwQyxJQUFHLElBQUksQ0FBQ1AsU0FBUyxDQUFDTyxFQUFFLENBQUNvQixJQUFJLENBQUNQLE9BQU8sRUFBQztnQkFDOUI2RTtZQUNKO1FBQ0o7UUFDQSxPQUFPQTtJQUNYO0lBRUF0RixjQUFvQjtRQUNoQixPQUFPLElBQUksQ0FBQ2dHLFNBQVMsQ0FBQ0MsT0FBTzNELElBQUksQ0FBQzRELE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQ0YsU0FBUyxDQUFDRyxNQUFNLEdBQUcsR0FBRztJQUM1RTtJQXJYQUMsWUFBWTNHLEtBQVksRUFBRXVDLENBQVMsRUFBRUcsQ0FBUyxDQUFDO2FBdEIvQ2hDLFNBQWlCO2FBQ2pCRSxTQUFpQjtRQUNqQixFQUFFO2FBQ0ZSLFlBQW9CO2FBQ3BCTyxVQUFrQjthQUNsQndELFlBQW9CO2FBQ3BCeUIsWUFBb0I7YUFDcEJOLGVBQXVCO2FBQ3ZCaUIsWUFBc0I7WUFBQztZQUFPO1lBQVE7WUFBUztTQUFNO1FBQ3JELEVBQUU7YUFDRjVFLFVBQW1CO2FBQ25CQyxXQUFvQjtRQUNwQixFQUFFO2FBQ0ZoQyxZQUFpQixFQUFFO2FBQ25CQyxZQUFpQixFQUFFO2FBQ25CQyxhQUFrQixFQUFFO1FBUWhCLElBQUksQ0FBQ0UsS0FBSyxHQUFHQTtRQUNiLHNEQUFzRDtRQUN0RCxzREFBc0Q7UUFFdEQsSUFBSSxDQUFDTCxTQUFTO1FBQ2QsNERBQTREO1FBQzVELElBQUksQ0FBQ0ssS0FBSyxDQUFDNEcsS0FBSyxDQUFDM0YsRUFBRSxDQUFDLGVBQWUsSUFBSSxDQUFDbUIsVUFBVSxFQUFFLElBQUk7UUFDeEQsSUFBSSxDQUFDcEMsS0FBSyxDQUFDNEcsS0FBSyxDQUFDM0YsRUFBRSxDQUFDLGFBQWEsSUFBSSxDQUFDZ0MsU0FBUyxFQUFFLElBQUk7SUFDekQ7QUE2V0o7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZ2FtZS9jb21wb25lbnRzL01hdGNoLnRzPzg2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2FtZSwgR2FtZU9iamVjdHMsIFNjZW5lIH0gZnJvbSBcInBoYXNlclwiO1xuXG5jbGFzcyBHZW17XG4gICAgZ2VtQ29sb3I6IHN0cmluZ1xuICAgIGdlbVNwcml0ZTogR2FtZU9iamVjdHMuU3ByaXRlXG4gICAgaXNFbXB0eTogYm9vbGVhblxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRjaHtcblxuICAgIHNjZW5lOiBQaGFzZXIuU2NlbmVcbiAgICBzdGFydFg6IG51bWJlciA9IDBcbiAgICBzdGFydFk6IG51bWJlciA9IDBcbiAgICAvL1xuICAgIGZpZWxkU2l6ZTogbnVtYmVyID0gN1xuICAgIGdlbVNpemU6IG51bWJlciA9IDEyOFxuICAgIHN3YXBTcGVlZDogbnVtYmVyID0gMjAwXG4gICAgZmFsbFNwZWVkOiBudW1iZXIgPSAxMDBcbiAgICBkZXN0cm95U3BlZWQ6IG51bWJlciA9IDIwMFxuICAgIGdlbUNvbG9yczogc3RyaW5nW10gPSBbJ2JsdWUnLCdncmVlbicsJ29yYW5nZScsJ3JlZCddXG4gICAgLy9cbiAgICBjYW5QaWNrOiBib29sZWFuID0gdHJ1ZVxuICAgIGRyYWdnaW5nOiBib29sZWFuID0gZmFsc2VcbiAgICAvL1xuICAgIGdhbWVBcnJheTogYW55ID0gW11cbiAgICBwb29sQXJyYXk6IGFueSA9IFtdXG4gICAgaW5wdXRBcnJheTogYW55ID0gW11cbiAgICBnZW1Hcm91cDogR2FtZU9iamVjdHMuR3JvdXBcbiAgICAvL1xuICAgIHNlbGVjdGVkR2VtOiBHZW0gfCBudWxsXG4gICAgc3dhcHBpbmdHZW1zOiBudW1iZXJcbiAgICByZW1vdmVNYXA6IGFueVxuXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCB4OiBudW1iZXIsIHk6IG51bWJlcil7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZVxuICAgICAgICAvLyB0aGlzLnN0YXJ0WCA9IHggLSAodGhpcy5maWVsZFNpemUqdGhpcy5nZW1TaXplIC8yKSBcbiAgICAgICAgLy8gdGhpcy5zdGFydFkgPSB5IC0gKHRoaXMuZmllbGRTaXplKnRoaXMuZ2VtU2l6ZSAvMikgXG5cbiAgICAgICAgdGhpcy5kcmF3RmllbGQoKTtcbiAgICAgICAgLy8gdGhpcy5zY2VuZS5pbnB1dC5vbihcInBvaW50ZXJkb3duXCIsIHRoaXMuZ2VtU2VsZWN0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY2VuZS5pbnB1dC5vbihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuc3RhcnRTd2lwZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NlbmUuaW5wdXQub24oXCJwb2ludGVydXBcIiwgdGhpcy5zdG9wU3dpcGUsIHRoaXMpO1xuICAgIH1cblxuICAgIGRyYXdGaWVsZCgpe1xuICAgICAgICB0aGlzLmdhbWVBcnJheSA9IFtdO1xuICAgICAgICB0aGlzLnBvb2xBcnJheSA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0QXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5nZW1Hcm91cCA9IHRoaXMuc2NlbmUuYWRkLmdyb3VwKCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZTsgaSArKyl7XG4gICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKClcbiAgICAgICAgICAgICAgICBsZXQgZ2VtID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WCArICh0aGlzLmdlbVNpemUgKiBqICsgdGhpcy5nZW1TaXplIC8gMiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WSArICh0aGlzLmdlbVNpemUgKiBpICsgdGhpcy5nZW1TaXplIC8gMiksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdlbUdyb3VwLmFkZChnZW0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBnZW1EYXRhOiBHZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbUNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZ2VtU3ByaXRlOiBnZW0sXG4gICAgICAgICAgICAgICAgICAgIGlzRW1wdHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdID0gZ2VtRGF0YVxuXG4gICAgICAgICAgICAgICAgZ2VtLm9uKFwicG9pbnRlcmRvd25cIiwgKCBwb2ludGVyOiBQaGFzZXIuSW5wdXQuUG9pbnRlcik9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW1TZWxlY3QocG9pbnRlcixnZW1EYXRhKVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgZ2VtLnNldEludGVyYWN0aXZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzTWF0Y2gocm93Om51bWJlciwgY29sOm51bWJlcik6IGJvb2xlYW57XG4gICAgICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbE1hdGNoKHJvdywgY29sKSB8fCB0aGlzLmlzVmVydGljYWxNYXRjaChyb3csIGNvbCk7XG4gICAgfVxuXG4gICAgaXNIb3Jpem9udGFsTWF0Y2gocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93LCBjb2wgLSAxKS5nZW1Db2xvciAmJiB0aGlzLmdlbUF0KHJvdywgY29sKS5nZW1Db2xvciA9PSB0aGlzLmdlbUF0KHJvdywgY29sIC0gMikuZ2VtQ29sb3I7XG4gICAgfVxuXG4gICAgaXNWZXJ0aWNhbE1hdGNoKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IGJvb2xlYW57XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW1BdChyb3csIGNvbCkuZ2VtQ29sb3IgPT0gdGhpcy5nZW1BdChyb3cgLSAxLCBjb2wpLmdlbUNvbG9yICYmIHRoaXMuZ2VtQXQocm93LCBjb2wpLmdlbUNvbG9yID09IHRoaXMuZ2VtQXQocm93IC0gMiwgY29sKS5nZW1Db2xvcjtcbiAgICB9XG4gICAgXG4gICAgZ2VtQXQocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogYW55e1xuICAgICAgICBpZihyb3cgPCAwIHx8IHJvdyA+PSB0aGlzLmZpZWxkU2l6ZSB8fCBjb2wgPCAwIHx8IGNvbCA+PSB0aGlzLmZpZWxkU2l6ZSl7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FtZUFycmF5W3Jvd11bY29sXTtcbiAgICB9XG5cbiAgICBnZW1TZWxlY3QocG9pbnRlcjogUGhhc2VyLklucHV0LlBvaW50ZXIsIGdlbTpHZW0pe1xuICAgICAgICBpZih0aGlzLmNhblBpY2spe1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAvLyBsZXQgcm93ID0gTWF0aC5mbG9vcihwb2ludGVyLnkgLyB0aGlzLmdlbVNpemUpO1xuICAgICAgICAgICAgLy8gbGV0IGNvbCA9IE1hdGguZmxvb3IocG9pbnRlci54IC8gdGhpcy5nZW1TaXplKTtcbiAgICAgICAgICAgIC8vIGxldCBwaWNrZWRHZW0gPSB0aGlzLmdlbUF0KHJvdywgY29sKVxuICAgICAgICAgICAgbGV0IHBpY2tlZEdlbSA9IGdlbVxuICAgICAgICAgICAgaWYocGlja2VkR2VtKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNlbGVjdGVkR2VtID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBwaWNrZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEuMik7XG4gICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0RGVwdGgoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0gPSBwaWNrZWRHZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJlVGhlU2FtZShwaWNrZWRHZW0sIHRoaXMuc2VsZWN0ZWRHZW0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJlTmV4dChwaWNrZWRHZW0sIHRoaXMuc2VsZWN0ZWRHZW0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtLmdlbVNwcml0ZS5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN3YXBHZW1zKHRoaXMuc2VsZWN0ZWRHZW0sIHBpY2tlZEdlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tlZEdlbS5nZW1TcHJpdGUuc2V0U2NhbGUoMS4yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gcGlja2VkR2VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRTd2lwZShwb2ludGVyOiBQaGFzZXIuSW5wdXQuUG9pbnRlcil7XG4gICAgICAgIGlmKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5zZWxlY3RlZEdlbSAhPSBudWxsKXtcbiAgICAgICAgICAgIGxldCBkZWx0YVggPSBwb2ludGVyLmRvd25YIC0gcG9pbnRlci54O1xuICAgICAgICAgICAgbGV0IGRlbHRhWSA9IHBvaW50ZXIuZG93blkgLSBwb2ludGVyLnk7XG4gICAgICAgICAgICBsZXQgZGVsdGFSb3cgPSAwO1xuICAgICAgICAgICAgbGV0IGRlbHRhQ29sID0gMDtcbiAgICAgICAgICAgIGlmKGRlbHRhWCA+IHRoaXMuZ2VtU2l6ZSAvIDIgJiYgTWF0aC5hYnMoZGVsdGFZKSA8IHRoaXMuZ2VtU2l6ZSAvIDQpe1xuICAgICAgICAgICAgICAgIGRlbHRhQ29sID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWx0YVggPCAtdGhpcy5nZW1TaXplIC8gMiAmJiBNYXRoLmFicyhkZWx0YVkpIDwgdGhpcy5nZW1TaXplIC8gNCl7XG4gICAgICAgICAgICAgICAgZGVsdGFDb2wgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVsdGFZID4gdGhpcy5nZW1TaXplIC8gMiAmJiBNYXRoLmFicyhkZWx0YVgpIDwgdGhpcy5nZW1TaXplIC8gNCl7XG4gICAgICAgICAgICAgICAgZGVsdGFSb3cgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRlbHRhWSA8IC10aGlzLmdlbVNpemUgLyAyICYmIE1hdGguYWJzKGRlbHRhWCkgPCB0aGlzLmdlbVNpemUgLyA0KXtcbiAgICAgICAgICAgICAgICBkZWx0YVJvdyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWx0YVJvdyArIGRlbHRhQ29sICE9IDApe1xuICAgICAgICAgICAgICAgIGxldCBwaWNrZWRHZW0gPSB0aGlzLmdlbUF0KHRoaXMuZ2V0R2VtUm93KHRoaXMuc2VsZWN0ZWRHZW0pICsgZGVsdGFSb3csIHRoaXMuZ2V0R2VtQ29sKHRoaXMuc2VsZWN0ZWRHZW0pICsgZGVsdGFDb2wpO1xuICAgICAgICAgICAgICAgIGlmKHBpY2tlZEdlbSAhPSAtMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHZW0uZ2VtU3ByaXRlLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN3YXBHZW1zKHRoaXMuc2VsZWN0ZWRHZW0sIHBpY2tlZEdlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wU3dpcGUoKXtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFyZVRoZVNhbWUoZ2VtMTogR2VtLCBnZW0yOiBHZW0pe1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW1Sb3coZ2VtMSkgPT0gdGhpcy5nZXRHZW1Sb3coZ2VtMikgJiYgdGhpcy5nZXRHZW1Db2woZ2VtMSkgPT0gdGhpcy5nZXRHZW1Db2woZ2VtMik7XG4gICAgfVxuXG4gICAgZ2V0R2VtUm93KGdlbTogR2VtKXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZ2VtLmdlbVNwcml0ZS55IC8gdGhpcy5nZW1TaXplKTtcbiAgICB9XG5cbiAgICBnZXRHZW1Db2woZ2VtOiBHZW0pe1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihnZW0uZ2VtU3ByaXRlLnggLyB0aGlzLmdlbVNpemUpO1xuICAgIH1cblxuICAgIGFyZU5leHQoZ2VtMTogR2VtLCBnZW0yOiBHZW0pe1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5nZXRHZW1Sb3coZ2VtMSkgLSB0aGlzLmdldEdlbVJvdyhnZW0yKSkgKyBNYXRoLmFicyh0aGlzLmdldEdlbUNvbChnZW0xKSAtIHRoaXMuZ2V0R2VtQ29sKGdlbTIpKSA9PSAxO1xuICAgIH1cblxuICAgIHN3YXBHZW1zKGdlbTE6IEdlbSwgZ2VtMjogR2VtLCBzd2FwQmFjazogYm9vbGVhbil7XG4gICAgICAgIHRoaXMuc3dhcHBpbmdHZW1zID0gMjtcbiAgICAgICAgdGhpcy5jYW5QaWNrID0gZmFsc2U7XG4gICAgICAgIGxldCBmcm9tQ29sb3IgPSBnZW0xLmdlbUNvbG9yO1xuICAgICAgICBsZXQgZnJvbVNwcml0ZSA9IGdlbTEuZ2VtU3ByaXRlO1xuICAgICAgICBsZXQgdG9Db2xvciA9IGdlbTIuZ2VtQ29sb3I7XG4gICAgICAgIGxldCB0b1Nwcml0ZSA9IGdlbTIuZ2VtU3ByaXRlO1xuICAgICAgICBsZXQgZ2VtMVJvdyA9IHRoaXMuZ2V0R2VtUm93KGdlbTEpO1xuICAgICAgICBsZXQgZ2VtMUNvbCA9IHRoaXMuZ2V0R2VtQ29sKGdlbTEpO1xuICAgICAgICBsZXQgZ2VtMlJvdyA9IHRoaXMuZ2V0R2VtUm93KGdlbTIpO1xuICAgICAgICBsZXQgZ2VtMkNvbCA9IHRoaXMuZ2V0R2VtQ29sKGdlbTIpO1xuICAgICAgICB0aGlzLmdhbWVBcnJheVtnZW0xUm93XVtnZW0xQ29sXS5nZW1Db2xvciA9IHRvQ29sb3I7XG4gICAgICAgIHRoaXMuZ2FtZUFycmF5W2dlbTFSb3ddW2dlbTFDb2xdLmdlbVNwcml0ZSA9IHRvU3ByaXRlO1xuICAgICAgICB0aGlzLmdhbWVBcnJheVtnZW0yUm93XVtnZW0yQ29sXS5nZW1Db2xvciA9IGZyb21Db2xvcjtcbiAgICAgICAgdGhpcy5nYW1lQXJyYXlbZ2VtMlJvd11bZ2VtMkNvbF0uZ2VtU3ByaXRlID0gZnJvbVNwcml0ZTtcbiAgICAgICAgdGhpcy50d2VlbkdlbShnZW0xLCBnZW0yLCBzd2FwQmFjayk7XG4gICAgICAgIHRoaXMudHdlZW5HZW0oZ2VtMiwgZ2VtMSwgc3dhcEJhY2spO1xuICAgIH1cblxuICAgIHR3ZWVuR2VtKGdlbTE6IEdlbSwgZ2VtMjogR2VtLCBzd2FwQmFjazogYm9vbGVhbil7XG4gICAgICAgIGxldCByb3cgPSB0aGlzLmdldEdlbVJvdyhnZW0xKTtcbiAgICAgICAgbGV0IGNvbCA9IHRoaXMuZ2V0R2VtQ29sKGdlbTEpO1xuICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgdGFyZ2V0czogdGhpcy5nYW1lQXJyYXlbcm93XVtjb2xdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgIHg6IGNvbCAqIHRoaXMuZ2VtU2l6ZSArIHRoaXMuZ2VtU2l6ZSAvIDIsXG4gICAgICAgICAgICB5OiByb3cgKiB0aGlzLmdlbVNpemUgKyB0aGlzLmdlbVNpemUgLyAyLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuc3dhcFNwZWVkLFxuICAgICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zd2FwcGluZ0dlbXMgLS07XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zd2FwcGluZ0dlbXMgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLm1hdGNoSW5Cb2FyZCgpICYmIHN3YXBCYWNrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3dhcEdlbXMoZ2VtMSwgZ2VtMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLm1hdGNoSW5Cb2FyZCgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1hdGNoZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5QaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkR2VtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF0Y2hJbkJvYXJkKCl7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZTsgaSArKyl7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemU7IGogKyspe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNNYXRjaChpLCBqKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF0Y2hlcygpe1xuICAgICAgICB0aGlzLnJlbW92ZU1hcCA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXBbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZTsgaiArKyl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXBbaV0ucHVzaCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtNYXRjaGVzKCdob3Jpem9udGFsJyk7XG4gICAgICAgIHRoaXMubWFya01hdGNoZXMoJ3ZlcnRpY2FsJyk7XG4gICAgICAgIHRoaXMuZGVzdHJveUdlbXMoKTtcbiAgICB9XG5cbiAgICBtYXJrTWF0Y2hlcyhkaXJlY3Rpb246IHN0cmluZyl7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkU2l6ZTsgaSArKyl7XG4gICAgICAgICAgICBsZXQgY29sb3JTdHJlYWsgPSAxO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRDb2xvciA9IC0xO1xuICAgICAgICAgICAgbGV0IHN0YXJ0U3RyZWFrID0gMDtcbiAgICAgICAgICAgIGxldCBjb2xvclRvV2F0Y2ggPSAwO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKXtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JUb1dhdGNoID0gdGhpcy5nZW1BdChpLCBqKS5nZW1Db2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JUb1dhdGNoID0gdGhpcy5nZW1BdChqLCBpKS5nZW1Db2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoY29sb3JUb1dhdGNoID09IGN1cnJlbnRDb2xvcil7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RyZWFrICsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihjb2xvclRvV2F0Y2ggIT0gY3VycmVudENvbG9yIHx8IGogPT0gdGhpcy5maWVsZFNpemUgLSAxKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoY29sb3JTdHJlYWsgPj0gMyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkhPUklaT05UQUwgOjogTGVuZ3RoID0gXCIgKyBjb2xvclN0cmVhayArIFwiIDo6IFN0YXJ0ID0gKFwiICsgaSArIFwiLFwiICsgc3RhcnRTdHJlYWsgKyBcIikgOjogQ29sb3IgPSBcIiArIGN1cnJlbnRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVkVSVElDQUwgOjogTGVuZ3RoID0gXCIgKyBjb2xvclN0cmVhayArIFwiIDo6IFN0YXJ0ID0gKFwiICsgc3RhcnRTdHJlYWsgKyBcIixcIiArIGkgKyBcIikgOjogQ29sb3IgPSBcIiArIGN1cnJlbnRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGsgPSAwOyBrIDwgY29sb3JTdHJlYWs7IGsgKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSAnaG9yaXpvbnRhbCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1hcFtpXVtzdGFydFN0cmVhayArIGtdICsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU1hcFtzdGFydFN0cmVhayArIGtdW2ldICsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydFN0cmVhayA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RyZWFrID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gY29sb3JUb1dhdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3lHZW1zKCl7XG4gICAgICAgIGxldCBkZXN0cm95ZWQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZFNpemU7IGkgKyspe1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuZmllbGRTaXplOyBqICsrKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnJlbW92ZU1hcFtpXVtqXSA+IDApe1xuICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZWQgKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudHdlZW5zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZGVzdHJveVNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVkIC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sQXJyYXkucHVzaCh0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlc3Ryb3llZCA9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlR2Vtc0ZhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsZW5pc2hGaWVsZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmlzRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1ha2VHZW1zRmFsbCgpe1xuICAgICAgICBmb3IobGV0IGkgPSB0aGlzLmZpZWxkU2l6ZSAtIDI7IGkgPj0gMDsgaSAtLSl7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgdGhpcy5maWVsZFNpemU7IGogKyspe1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhbGxUaWxlcyA9IHRoaXMuaG9sZXNCZWxvdyhpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZmFsbFRpbGVzID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnR3ZWVucy5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUueSArIGZhbGxUaWxlcyAqIHRoaXMuZ2VtU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5mYWxsU3BlZWQgKiBmYWxsVGlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaSArIGZhbGxUaWxlc11bal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VtU3ByaXRlOiB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VtQ29sb3I6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRW1wdHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvbGVzQmVsb3cocm93OiBudW1iZXIsIGNvbDogbnVtYmVyKXtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IHJvdyArIDE7IGkgPCB0aGlzLmZpZWxkU2l6ZTsgaSArKyl7XG4gICAgICAgICAgICBpZih0aGlzLmdhbWVBcnJheVtpXVtjb2xdLmlzRW1wdHkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlcGxlbmlzaEZpZWxkKCl7XG4gICAgICAgIGxldCByZXBsZW5pc2hlZCA9IDA7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmZpZWxkU2l6ZTsgaiArKyl7XG4gICAgICAgICAgICBsZXQgZW1wdHlTcG90cyA9IHRoaXMuaG9sZXNJbkNvbChqKTtcbiAgICAgICAgICAgIGlmKGVtcHR5U3BvdHMgPiAwKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZW1wdHlTcG90czsgaSArKyl7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaGVkICsrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tQ29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtQ29sb3IgPSByYW5kb21Db2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlID0gdGhpcy5wb29sQXJyYXkucG9wKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lQXJyYXlbaV1bal0uZ2VtU3ByaXRlLnNldFRleHR1cmUocmFuZG9tQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVBcnJheVtpXVtqXS5nZW1TcHJpdGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS54ID0gdGhpcy5nZW1TaXplICogaiArIHRoaXMuZ2VtU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS55ID0gdGhpcy5nZW1TaXplIC8gMiAtIChlbXB0eVNwb3RzIC0gaSkgKiB0aGlzLmdlbVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZS5hbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZUFycmF5W2ldW2pdLmlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50d2VlbnMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IHRoaXMuZ2FtZUFycmF5W2ldW2pdLmdlbVNwcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuZ2VtU2l6ZSAqIGkgKyB0aGlzLmdlbVNpemUgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZmFsbFNwZWVkICogZW1wdHlTcG90cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrU2NvcGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaGVkIC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlcGxlbmlzaGVkID09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLm1hdGNoSW5Cb2FyZCgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudGltZS5hZGRFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IDI1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdGhpcy5oYW5kbGVNYXRjaGVzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblBpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvbGVzSW5Db2woY29sOiBudW1iZXIpe1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRTaXplOyBpICsrKXtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2FtZUFycmF5W2ldW2NvbF0uaXNFbXB0eSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmFuZG9tQ29sb3IoKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbUNvbG9yc1tQaGFzZXIuTWF0aC5CZXR3ZWVuKDAsIHRoaXMuZ2VtQ29sb3JzLmxlbmd0aCAtIDEpXTtcbiAgICB9XG59Il0sIm5hbWVzIjpbIkdlbSIsIk1hdGNoIiwiZHJhd0ZpZWxkIiwiZ2FtZUFycmF5IiwicG9vbEFycmF5IiwiaW5wdXRBcnJheSIsImdlbUdyb3VwIiwic2NlbmUiLCJhZGQiLCJncm91cCIsImkiLCJmaWVsZFNpemUiLCJqIiwiY29sb3IiLCJyYW5kb21Db2xvciIsImdlbSIsInNwcml0ZSIsInN0YXJ0WCIsImdlbVNpemUiLCJzdGFydFkiLCJnZW1EYXRhIiwiZ2VtQ29sb3IiLCJnZW1TcHJpdGUiLCJpc0VtcHR5Iiwib24iLCJwb2ludGVyIiwiZ2VtU2VsZWN0Iiwic2V0SW50ZXJhY3RpdmUiLCJpc01hdGNoIiwicm93IiwiY29sIiwiaXNIb3Jpem9udGFsTWF0Y2giLCJpc1ZlcnRpY2FsTWF0Y2giLCJnZW1BdCIsImNhblBpY2siLCJkcmFnZ2luZyIsInBpY2tlZEdlbSIsInNlbGVjdGVkR2VtIiwic2V0U2NhbGUiLCJzZXREZXB0aCIsImFyZVRoZVNhbWUiLCJhcmVOZXh0Iiwic3dhcEdlbXMiLCJzdGFydFN3aXBlIiwiZGVsdGFYIiwiZG93blgiLCJ4IiwiZGVsdGFZIiwiZG93blkiLCJ5IiwiZGVsdGFSb3ciLCJkZWx0YUNvbCIsIk1hdGgiLCJhYnMiLCJnZXRHZW1Sb3ciLCJnZXRHZW1Db2wiLCJzdG9wU3dpcGUiLCJnZW0xIiwiZ2VtMiIsImZsb29yIiwic3dhcEJhY2siLCJzd2FwcGluZ0dlbXMiLCJmcm9tQ29sb3IiLCJmcm9tU3ByaXRlIiwidG9Db2xvciIsInRvU3ByaXRlIiwiZ2VtMVJvdyIsImdlbTFDb2wiLCJnZW0yUm93IiwiZ2VtMkNvbCIsInR3ZWVuR2VtIiwidHdlZW5zIiwidGFyZ2V0cyIsImR1cmF0aW9uIiwic3dhcFNwZWVkIiwiY2FsbGJhY2tTY29wZSIsIm9uQ29tcGxldGUiLCJtYXRjaEluQm9hcmQiLCJoYW5kbGVNYXRjaGVzIiwicmVtb3ZlTWFwIiwicHVzaCIsIm1hcmtNYXRjaGVzIiwiZGVzdHJveUdlbXMiLCJkaXJlY3Rpb24iLCJjb2xvclN0cmVhayIsImN1cnJlbnRDb2xvciIsInN0YXJ0U3RyZWFrIiwiY29sb3JUb1dhdGNoIiwiY29uc29sZSIsImxvZyIsImsiLCJkZXN0cm95ZWQiLCJhbHBoYSIsImRlc3Ryb3lTcGVlZCIsInZpc2libGUiLCJtYWtlR2Vtc0ZhbGwiLCJyZXBsZW5pc2hGaWVsZCIsImZhbGxUaWxlcyIsImhvbGVzQmVsb3ciLCJmYWxsU3BlZWQiLCJyZXN1bHQiLCJyZXBsZW5pc2hlZCIsImVtcHR5U3BvdHMiLCJob2xlc0luQ29sIiwicG9wIiwic2V0VGV4dHVyZSIsInRpbWUiLCJhZGRFdmVudCIsImRlbGF5IiwiY2FsbGJhY2siLCJnZW1Db2xvcnMiLCJQaGFzZXIiLCJCZXR3ZWVuIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJpbnB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/game/components/Match.ts\n"));

/***/ })

});